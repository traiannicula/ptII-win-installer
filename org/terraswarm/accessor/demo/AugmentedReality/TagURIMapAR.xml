<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="TagURIMapAR" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopTime" class="ptolemy.data.expr.Parameter" value="">
        </property>
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[55.0, 155.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={301, 140, 1139, 750}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[905, 640]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{452.5, 320.0}">
    </property>
    <property name="_layoutConfiguration" class="ptolemy.vergil.basic.layout.ActorLayoutConfiguration">
        <property name="includeDecorations" class="ptolemy.data.expr.Parameter" value="false">
            <display name="Include decorations"/>
        </property>
        <property name="spacing" class="ptolemy.actor.parameters.DoubleRangeParameter" value="2.0">
            <display name="Object spacing"/>
        </property>
        <property name="logAspectRatio" class="ptolemy.actor.parameters.DoubleRangeParameter" value="-1.0">
            <display name="Aspect ratio"/>
        </property>
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This model looks for AR tags in an image, then using the ID of the AR tag, looks up an&#10;accessor, reifies it, and then overlays the sensor data provided by the accessor on the image.&#10;If the accessor provides a schema, then it will also construct a form for data entry to be sent&#10;back to the accessor.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[20.0, 25.0]">
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This variant of the augmented reality demo changes the original, AugmentedRealityBasic, where the &#10;TagToAccessor knows upon initialization the mapping between april tag index and accessor.&#10;In this variant, we create URIs for AprilTags based on location. This scheme enables the use of&#10;an ontology mapping accessor (DummyTagURIMap) to obtain the accessor.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[20.0, 435.0]">
        </property>
    </property>
    <property name="Annotation3" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Author: Edward A. Lee">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[10.0, 530.0]">
        </property>
    </property>
    <property name="Annotation4" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="See the AugmentedRealityBasic model.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[420.0, 525.0]">
        </property>
        <property name="LiveLink" class="ptolemy.actor.gui.LiveLink" value="$CLASSPATH/org/terraswarm/accessor/demo/AugmentedReality/AugmentedRealityBasic.xml">
            <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
                <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
                </property>
            </property>
            <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
                <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">LL</text>
      </svg>
    </configure>
            </property>
            <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{395, 280}">
            </property>
        </property>
        <property name="IconLink" class="ptolemy.vergil.basic.export.web.IconLink" value="http://ptolemy.eecs.berkeley.edu/ptolemyII/ptII11.0/ptII/org/terraswarm/accessor/demo/AugmentedReality/AugmentedRealityBasic/index.html">
            <property name="linkTarget" class="ptolemy.vergil.basic.export.web.LinkTarget" value="_self">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{450, 180}">
            </property>
        </property>
    </property>
    <entity name="ObjectRecognizer" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2015-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/**&#10; * Accessor to detect AprilTags in an image or stream of images.&#10; * An AprilTag is a pattern of dark and light squares similar to a QR code but easier for&#10; * cameras to detect robustly and at a distance.&#10; * AprilTags were created by Associate Professor Edwin Olson (ebolson@umich.edu),&#10; * EECS, University of Michigan. See [https://april.eecs.umich.edu/](https://april.eecs.umich.edu/#in_browser).&#10; * &#10; * The implementation of this accessor on the Ptolemy II/Nashorn accessor host&#10; * uses an older Java implementation of the AprilTags detector written by Edwin Olson&#10; * and more recently supplanted by a C version that performs much better. But this Java&#10; * version is more easily included in Ptolemy II in a portable way. If you need better&#10; * performance, consider replacing this with the C implementation and using JNI to interface&#10; * to Ptolemy II.&#10; * &#10; * https://april.eecs.umich.edu/software/apriltag.html contains a set of&#10; * pregenerated tags as png and PostScript files.  However, these are of&#10; * low resolution.  To scale them, use linear interpolation to avoid blurring.&#10; * For example, with ImageMagik, use:&#10; *&#10; *  mogrify -scale 1000x1000 *.png; convert *.png tag36h11.pdf&#10; *&#10; * Or, search the web for &quot;tag 36H11&quot;.  &#10; *&#10; * In the Ptolemy tree, a sample file may be found at&#10; * $PTII/ptolemy/actor/lib/jjs/modules/aprilTags//demo/AprilTags/tag36_11_00586.pdf&#10; *&#10; * The input to this accessor is an image or a stream of images, e.g. from the Camera&#10; * accessor.  There are two outputs. The one named _output_ is a modified version&#10; * of the input image that outlines any detected AprilTags in the image&#10; * and indicates their center and ID.  The _tags_ output is an array of&#10; * objects representing the detected tags. Each object includes the following fields:&#10; * &#10; * + _id_: The ID of the detected tag.&#10; * + _center_: An array with two doubles giving the center of the tag in pixel coordinates.&#10; * + _perimeter_: An array with four arrays, each of which gives the x and y coordinates of&#10; *   a corner of the AprilTag.&#10; * &#10; * The AprilTags detector has a large number of parameters that can be tuned via&#10; * the _options_ input. To set an option, provide a JSON object with a field matching&#10; * the option name.  The options are described below using descriptions provided by&#10; * by Edwin Olson in his Java implementation of an AprilTag detector:&#10; * &#10; * + _MagThresh_: When growing components, the intra component variation is&#10; *   allowed to grow when the component is small in size. This&#10; *   threshold affects how much. The default is 1200.&#10; * + _MaxEdgeCost_: Set the maximum angle range allowed for the gradient directions&#10; *   when connecting edges, in radians. This defaults to the radian&#10; *   equivalent of 30 degrees.&#10; * + _MinMag_: Set the gradient magnitude threshold for ignoring pixels.&#10; *   Do not consider pixels whose gradient magnitude is less than&#10; *   minMag. Small values make the detector more sensitive, but also&#10; *   force us to consider many more edges resulting in slower&#10; *   computation time. A value of 0.001 is very sensitive. A value&#10; *   of 0.01 is quite fast. The default is 0.004.&#10; * + _SegDecimate_: Set whether decimating before segmenting is enabled.&#10; *   Instead of blurring the input image before segmentation, we&#10; *   can achieve similar effects by decimating the image by a factor&#10; *   of two. When enabled, this option applies a block LPF filter of&#10; *   width 2, then decimates the image. With this option, not only&#10; *   can we safely set segSigma = 0, but the slowest part of the&#10; *   algorithm (the segmentation) runs about 4 times faster. The&#10; *   downside is that the position of the targets is determined&#10; *   based on the segmentation: lower resolution will result in more&#10; *   localization error. However, the effect on quality is quite&#10; *   modest, and this optimization is generally recommended (along&#10; *   with segSigma = 0). If segSigma is non-zero, the filtering by&#10; *   segSigma occurs first, followed by the block LPF, and the&#10; *   decimation. This defaults to false, indicating that the option&#10; *   is not enabled.&#10; * + _SegSigma_: Set the Gaussian smoothing kernel applied to image (0 == no filter)&#10; *   used when detecting the outline of the box. It is almost always&#10; *   useful to have some filtering, since the loss of small details&#10; *   won't hurt. Recommended value = 0.8 (the default). The case where sigma ==&#10; *   segsigma has been optimized to avoid a redundant filter&#10; *   operation.&#10; * + _Sigma_: Set the Gaussian smoothing kernel applied to image (0 == no filter, the default)&#10; *   used when sampling bits. Filtering is a good idea in cases&#10; *   where A) a cheap camera is introducing artifical sharpening, B)&#10; *   the bayer pattern is creating artifcats, C) the sensor is very&#10; *   noisy and/or has hot/cold pixels. However, filtering makes it&#10; *   harder to decode very small tags. Reasonable values are 0, or&#10; *   [0.8, 1.5].&#10; * + _TagFamily_: Set the name of the tag family being detected.&#10; *   This defaults to &quot;Tag36h11&quot;.&#10; *   The supported families are &quot;Tag16h5&quot;, &quot;Tag25h7&quot;, &quot;Tag25h9&quot;, &quot;Tag36h10&quot;, and &quot;Tag36h11&quot;.&#10; *   The default family seems least susceptible to false positives.&#10; * + _ThetaThresh_: When growing components, the intra component variation is&#10; *   allowed to grow when the component is small in size. This&#10; *   threshold affects how much. The default is 100.&#10; * &#10; *   @accessor image/AprilTags&#10; *   @author Edward A. Lee (eal@eecs.berkeley.edu)&#10; *   @input input An input image.&#10; *   @output output An output image, with detected AprilTags outlined in green and identified.&#10; *   @output tags An array of objects, one object for each tag detected in the image.&#10; *   @parameter options The options for the detector. This is a JSON object with fields defined above.&#10; *   It defaults to an empty object, meaning to use default values for all the otpions.&#10; *   @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals addInputHandler, exports, get, input, output, removeInputHandler, require, send,  */&#10;/*jshint globalstrict: true */&#10;&quot;use strict&quot;;&#10;&#10;var aprilTags = require('aprilTags');&#10;&#10;exports.setup = function () {&#10;    this.input('input');&#10;    this.output('output');&#10;    this.output('tags');&#10;    this.input('options', {&#10;        'type': 'JSON',&#10;        'value': ''&#10;    });&#10;};&#10;&#10;var handle;&#10;exports.initialize = function () {&#10;    var self = this;&#10;    handle = self.addInputHandler('input', function () {&#10;        var options = self.get('options');&#10;        var image = self.get('input');&#10;        var result = aprilTags.filter(image, options);&#10;        self.send('output', result);&#10;        var tags = aprilTags.tags();&#10;        if (tags) {&#10;            self.send('tags', tags);&#10;        }&#10;    });&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (handle) {&#10;        this.removeInputHandler(handle);&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/image/AprilTags.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor to detect AprilTags in an image or stream of images.&#10;An AprilTag is a pattern of dark and light squares similar to a QR code but easier for&#10;cameras to detect robustly and at a distance.&#10;AprilTags were created by Associate Professor Edwin Olson (&lt;a href=&quot;mailto:ebolson@umich.edu&quot;&gt;ebolson@umich.edu&lt;/a&gt;),&#10;EECS, University of Michigan. See &lt;a href=&quot;https://april.eecs.umich.edu/#in_browser&quot;&gt;https://april.eecs.umich.edu/&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;The implementation of this accessor on the Ptolemy II/Nashorn accessor host&#10;uses an older Java implementation of the AprilTags detector written by Edwin Olson&#10;and more recently supplanted by a C version that performs much better. But this Java&#10;version is more easily included in Ptolemy II in a portable way. If you need better&#10;performance, consider replacing this with the C implementation and using JNI to interface&#10;to Ptolemy II.&lt;/p&gt;&#10;&lt;p&gt;https://april.eecs.umich.edu/software/apriltag.html contains a set of&#10;pregenerated tags as png and PostScript files.  However, these are of&#10;low resolution.  To scale them, use linear interpolation to avoid blurring.&#10;For example, with ImageMagik, use:&lt;/p&gt;&#10;&lt;p&gt; mogrify -scale 1000x1000 &lt;em&gt;.png; convert &lt;/em&gt;.png tag36h11.pdf&lt;/p&gt;&#10;&lt;p&gt;Or, search the web for &amp;quot;tag 36H11&amp;quot;.  &lt;/p&gt;&#10;&lt;p&gt;In the Ptolemy tree, a sample file may be found at&#10;$PTII/ptolemy/actor/lib/jjs/modules/aprilTags//demo/AprilTags/tag36_11_00586.pdf&lt;/p&gt;&#10;&lt;p&gt;The input to this accessor is an image or a stream of images, e.g. from the Camera&#10;accessor.  There are two outputs. The one named &lt;em&gt;output&lt;/em&gt; is a modified version&#10;of the input image that outlines any detected AprilTags in the image&#10;and indicates their center and ID.  The &lt;em&gt;tags&lt;/em&gt; output is an array of&#10;objects representing the detected tags. Each object includes the following fields:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;_id_: The ID of the detected tag.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;center&lt;/em&gt;: An array with two doubles giving the center of the tag in pixel coordinates.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;perimeter&lt;/em&gt;: An array with four arrays, each of which gives the x and y coordinates of&#10;a corner of the AprilTag.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;The AprilTags detector has a large number of parameters that can be tuned via&#10;the &lt;em&gt;options&lt;/em&gt; input. To set an option, provide a JSON object with a field matching&#10;the option name.  The options are described below using descriptions provided by&#10;by Edwin Olson in his Java implementation of an AprilTag detector:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;em&gt;MagThresh&lt;/em&gt;: When growing components, the intra component variation is&#10;allowed to grow when the component is small in size. This&#10;threshold affects how much. The default is 1200.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;MaxEdgeCost&lt;/em&gt;: Set the maximum angle range allowed for the gradient directions&#10;when connecting edges, in radians. This defaults to the radian&#10;equivalent of 30 degrees.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;MinMag&lt;/em&gt;: Set the gradient magnitude threshold for ignoring pixels.&#10;Do not consider pixels whose gradient magnitude is less than&#10;minMag. Small values make the detector more sensitive, but also&#10;force us to consider many more edges resulting in slower&#10;computation time. A value of 0.001 is very sensitive. A value&#10;of 0.01 is quite fast. The default is 0.004.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;SegDecimate&lt;/em&gt;: Set whether decimating before segmenting is enabled.&#10;Instead of blurring the input image before segmentation, we&#10;can achieve similar effects by decimating the image by a factor&#10;of two. When enabled, this option applies a block LPF filter of&#10;width 2, then decimates the image. With this option, not only&#10;can we safely set segSigma = 0, but the slowest part of the&#10;algorithm (the segmentation) runs about 4 times faster. The&#10;downside is that the position of the targets is determined&#10;based on the segmentation: lower resolution will result in more&#10;localization error. However, the effect on quality is quite&#10;modest, and this optimization is generally recommended (along&#10;with segSigma = 0). If segSigma is non-zero, the filtering by&#10;segSigma occurs first, followed by the block LPF, and the&#10;decimation. This defaults to false, indicating that the option&#10;is not enabled.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;SegSigma&lt;/em&gt;: Set the Gaussian smoothing kernel applied to image (0 == no filter)&#10;used when detecting the outline of the box. It is almost always&#10;useful to have some filtering, since the loss of small details&#10;won't hurt. Recommended value = 0.8 (the default). The case where sigma ==&#10;segsigma has been optimized to avoid a redundant filter&#10;operation.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;Sigma&lt;/em&gt;: Set the Gaussian smoothing kernel applied to image (0 == no filter, the default)&#10;used when sampling bits. Filtering is a good idea in cases&#10;where A) a cheap camera is introducing artifical sharpening, B)&#10;the bayer pattern is creating artifcats, C) the sensor is very&#10;noisy and/or has hot/cold pixels. However, filtering makes it&#10;harder to decode very small tags. Reasonable values are 0, or&#10;[0.8, 1.5].&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;TagFamily&lt;/em&gt;: Set the name of the tag family being detected.&#10;This defaults to &amp;quot;Tag36h11&amp;quot;.&#10;The supported families are &amp;quot;Tag16h5&amp;quot;, &amp;quot;Tag25h7&amp;quot;, &amp;quot;Tag25h9&amp;quot;, &amp;quot;Tag36h10&amp;quot;, and &amp;quot;Tag36h11&amp;quot;.&#10;The default family seems least susceptible to false positives.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;ThetaThresh&lt;/em&gt;: When growing components, the intra component variation is&#10;allowed to grow when the component is small in size. This&#10;threshold affects how much. The default is 100.&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee (eal@eecs.berkeley.edu)">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" value="An input image.">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="An output image, with detected AprilTags outlined in green and identified.">
            </property>
            <property name="tags (port)" class="ptolemy.kernel.util.StringAttribute" value="An array of objects, one object for each tag detected in the image.">
            </property>
            <property name="options (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The options for the detector. This is a JSON object with fields defined above.&#10;  It defaults to an empty object, meaning to use default values for all the otpions.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="options" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[250.0, 230.0]">
        </property>
        <port name="options" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="input" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="tags" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="ImageReader" class="ptolemy.actor.lib.image.ImageReader">
        <property name="fileOrURL" class="ptolemy.data.expr.FileParameter" value="MechanicalRoom.jpg">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{150.0, 350.0}">
        </property>
    </entity>
    <entity name="IndexGenerator" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Upon receiving the first non-empty array of tags at the input, this script&#10;// outputs a 0 to specify to use the first tag. Whenever it receives an&#10;// empty *next* input, it switches to the next tag in the list, wrapping&#10;// around to the first one when it has scrolled through the tags.&#10;&#10;exports.setup = function() {&#10;	this.input('tags');&#10;	this.input('next');&#10;	this.output('reset', {&#10;		'type': 'boolean'&#10;	});&#10;	this.output('index', {&#10;		'type': 'int'&#10;	});&#10;}&#10;&#10;exports.initialize = function() {&#10;	var thiz = this;&#10;	&#10;	var first = true;&#10;	var index = 0;&#10;	var nextTag = false;&#10;	&#10;	this.addInputHandler('tags', function() {&#10;		var tags = thiz.get('tags');&#10;		if (first &amp;&amp; tags &amp;&amp; tags.length &gt; 0) {&#10;			thiz.send('index', index);&#10;			first = false;&#10;			thiz.send('reset', true);&#10;			return;&#10;		}&#10;		if (nextTag) {&#10;			nextTag = false;&#10;			// Only switch if there is more than one tag.&#10;			if (tags &amp;&amp; tags.length &gt; 1) {&#10;				index++;&#10;				if (index &gt;= tags.length) {&#10;					index = 0;&#10;				}&#10;				thiz.send('index', index);&#10;				thiz.send('reset', true);&#10;			}&#10;		}&#10;		if (!tags) {&#10;			thiz.send('reset', true);&#10;		}&#10;	});&#10;	&#10;	this.addInputHandler('next', function() {&#10;		var next = thiz.get('next');&#10;		if (typeof next === 'string') {&#10;			next = JSON.parse(next);&#10;		}&#10;		if (!next || (Object.keys(next).length === 0 &#10;				&amp;&amp; next.constructor === Object)) {&#10;			// Empty object or null received.&#10;			nextTag = true;&#10;		}&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[395.0, 155.0]">
        </property>
        <port name="tags" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="reset" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="index" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="next" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="ConstructUI" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// First attempt based on: https://stackoverflow.com/questions/12905849/generating-html-forms-from-json-or-xml-feed-using-jquery&#10;// A proper Form generator will require a DOM parser to insert things into an existing HTML source. This is just a one-off accessor.&#10;&#10;exports.setup = function() {&#10;	this.input('reset');&#10;	this.input('translate');&#10;	this.input('data');&#10;	this.input('spec', {'type':'JSON'});&#10;	this.input('image');&#10;	this.output('html', {'type':'string'});&#10;	this.output('resources');&#10;	this.output('update', {'type':'JSON'});&#10;}&#10;exports.initialize = function() {&#10;	var self = this;&#10;	var htmlSent = false;&#10;	&#10;	this.addInputHandler('spec', function() {&#10;		var spec = self.get('spec');&#10;		var id = &quot;input&quot;;&#10;       	var property = &quot;html&quot;;&#10;       	var content = '&lt;h2&gt;Inputs:&lt;/h2&gt;&lt;form action=&quot;/&quot; method=&quot;post&quot; target=&quot;blankIframe&quot; id=&quot;form&quot;/&gt;&lt;table&gt;';&#10;		// FIXME: Handle types other than object, e.g. string, number.&#10;		if (spec.type === 'object') {&#10;			for (prop in spec.properties) {&#10;				var name = prop;&#10;				var entry = spec.properties[prop];&#10;				if (entry['title']) {&#10;					name = entry['title'];&#10;				}&#10;				var type = 'string';&#10;				// FIXME: could use entry['type'] if it exists, but HTML5&#10;				// types and JSON schema types do not match.&#10;				content += '&lt;tr&gt;&lt;td&gt;'&#10;						+ name&#10;						+ '&lt;/td&gt;&lt;td&gt;'&#10;						+ '&lt;input type=&quot;'&#10;						+ type&#10;						+ '&quot; name=&quot;' &#10;						+ prop&#10;						+ '&quot; form=&quot;form&quot;/&gt;'&#10;						+ '&lt;/td&gt;&lt;/tr&gt;';&#10;			}&#10;		}&#10;		content += '&lt;/table&gt;&lt;input type=&quot;submit&quot; value=&quot;Submit&quot; form=&quot;form&quot;&gt;';&#10;		&#10;       	self.send('update', {&#10;       		'id': id,&#10;       		'property': property,&#10;       		'content': content,&#10;       	});&#10;	});&#10;&#10;	this.addInputHandler('image', function() {&#10;		var image = self.get('image');&#10;		// Send the new image, updating the resource named 'image.jpg'.&#10;		self.send('resources', {&#10;			'image.jpg': {&#10;				'data': image,&#10;				'contentType': 'image/jpeg'&#10;			}&#10;		});&#10;		// Send an update to force the browser to update the DOM img element.&#10;		self.send('update', {&#10;			'id':'image',&#10;			'property':'src',&#10;			'content':'image.jpg'&#10;		});&#10;		var html = '&lt;h1&gt;Augmented Reality Demo&lt;/h1&gt;\n';&#10;		&#10;		html += '&lt;div id=&quot;container&quot;&gt;\n\&#10;		    &lt;img src=&quot;image.jpg&quot; id=&quot;image&quot; alt=&quot;Mechanical Room Image&quot;&gt;\n\&#10;		    &lt;div id=&quot;overlay&quot; style=&quot;top:50%;left:50%;&quot;&gt;\n\&#10;		        &lt;div id=&quot;output&quot;&gt;No data&lt;/div&gt;&lt;br/&gt;\n\&#10;		        &lt;div id=&quot;input&quot;&gt;&lt;/div&gt;\n\&#10;		    &lt;/div&gt;\n\&#10;		&lt;/div&gt;\n\&#10;		&lt;form action=&quot;/&quot; method=&quot;post&quot; target=&quot;blankIframe&quot;&gt;\n\&#10;			&lt;input type=&quot;submit&quot; value=&quot;Next Tag&quot; name=&quot;next&quot;/&gt;\n\&#10;		&lt;/form&gt;\n';&#10;		&#10;		// Firefox insists on displaying the response to the post,&#10;		// so we direct the response to a small iframe.&#10;		html += '&lt;iframe name=&quot;blankIframe&quot; id=&quot;blankIframe&quot; height=0 width=0/&gt;';&#10;		&#10;		if (!htmlSent) {&#10;			self.send('html', html);&#10;			htmlSent = true;&#10;		}&#10;	});&#10;	&#10;	this.addInputHandler('translate', function() {&#10;		var translate = self.get('translate');&#10;		if (translate !== null &amp;&amp; translate[0] !== null &amp;&amp; translate[1] !== null) {&#10;            var id = &quot;overlay&quot;;&#10;            var property = &quot;style&quot;;&#10;            // FIXME: Hardcoded to container width of 1000px and Height 600.&#10;            // Assume image is not scaled.&#10;            var left = 100*translate[0]/1000;&#10;            var top = 100*translate[1]/600;&#10;            var content = &quot;top:&quot; + top + &quot;%;left:&quot; + left + &quot;%;&quot;;&#10;            self.send('update', {&#10;            	'id': id,&#10;            	'property': property,&#10;            	'content': content,&#10;            });&#10;        }&#10;	});&#10;	&#10;	this.addInputHandler('data', function() {&#10;		var id = &quot;output&quot;;&#10;        var property = &quot;html&quot;;&#10;        var content = '&lt;table&gt;';&#10;        &#10;        var json = self.get('data');&#10;		try {&#10;			json = JSON.parse(json);&#10;		} catch(err) {&#10;			json = {'error': err.message};&#10;		}&#10;		&#10;		if (!json || Object.keys(json).length === 0) {&#10;			content += '&lt;tr&gt;&lt;td&gt;No Data&lt;/td&gt;&lt;/tr&gt;';&#10;		} else {&#10;			for (prop in json) {&#10;				var value = util.inspect(json[prop]);&#10;				content += '&lt;tr&gt;&lt;td&gt;' + prop + '&lt;/td&gt;&lt;td&gt;' + value + '&lt;/td&gt;&lt;/tr&gt;';&#10;			}&#10;		}&#10;		content += '&lt;/table&gt;';&#10;&#10;        self.send('update', {&#10;        	'id': id,&#10;           	'property': property,&#10;           	'content': content,&#10;        });&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[695.0, 165.0]">
        </property>
        <port name="reset" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="translate" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="data" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="html" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="resources" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="update" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="spec" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="image" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="UserInterface" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Accessor that provides a user interface based on HTML5 on the local host.&#10;//&#10;// Copyright (c) 2017 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Accessor that provides a user interface based on HTML5 on the local host.&#10; *  The initial content on the page may be specified using the *content*&#10; *  parameter and HTML header content may be specified using *header*.&#10; *  &#10; *  Whatever text is received on the *html* input port will replace the content&#10; *  of the web page. Normally, this will be HTML text without any DOCTYPE or&#10; *  header and without a body tag. Each time new text is received, the content&#10; *  of the page will be replaced.&#10; *  &#10; *  The page will be opened upon initialize if *content* is not empty.&#10; *  Otherwise, it will be opened when the first *html* input is received.&#10; *  &#10; *  The *resources* input can be used to provide resources, such as images,&#10; *  that will be used by the HTML content provided on the *html* input.&#10; *  Note that you probably will also have to provide an *update* input (see below)&#10; *  to force the user interface to update the page using the specified resource.&#10; *  &#10; *  The *update* input can be used to instruct the user interface to replace content&#10; *  within the page, vs. the *html* input which replaces the entire page.&#10; *  The value of an *update* input is expected to be an object with three properties,&#10; *  *id*, *property*, and *content*.&#10; *  &#10; *  The *id* property refers to a the ID of&#10; *  a DOM element in the content of the page, where the content has been provided&#10; *  either via the *content* parameter or the *html* input. For example, your&#10; *  page may include:&#10; *  &lt;pre&gt;&#10; *     &amp;lt;div id=&quot;foo&quot;&amp;gt;&amp;lt;/div&amp;gt;&#10; *  &lt;/pre&gt;&#10; *  or&#10; *  &lt;pre&gt;&#10; *     &amp;lt;img id=&quot;bar&quot; src=&quot;image.jpg&quot;/&amp;gt;&#10; *  &lt;/pre&gt;&#10; *   *  @param id The ID.&#10; *  The *property* field specifies what property of the DOM element with the&#10; *  specified ID is to be updated. If *property* is &quot;html&quot;, then the&#10; *  DOM object is updated by invoking the jQuery html() function&#10; *  with the specified *content* as an argument. For example, if *id* is &quot;foo&quot;,&#10; *  *property* is &quot;html&quot;, and *content* is &quot;Hello World!&quot;, then the above div&#10; *  will be populated with the text &quot;Hello World!&quot; on the web page.&#10; *  The *content* can include any HTML markup or even scripts, which will be executed.&#10; *  &#10; *  If *property* is anything other than 'html', then the DOM element's *property*&#10; *  attribute will be assigned the value of *content*.&#10; *  A *property* value of 'src', however, is treated specially.&#10; *  A *property* value of 'src' can be used, for example, to replace the image in the above img tag.&#10; *  Just send the updated image to the *resources* input and send this to the&#10; *  *update* input:&#10; *  &lt;pre&gt;&#10; *     {'id':'bar', 'property':'src', 'content':'image.jpg'}&#10; *  &lt;/pre&gt;&#10; *  &#10; *  Note that to get the user interface to actually replace the image, we may have to play some tricks.&#10; *  If the user interface is implemented by a browser, then the browser&#10; *  normally caches an image that it has previously retrieved&#10; *  and it will use the cached version of the image rather than obtaining the new image&#10; *  from the server.  To force the user interface to refresh the image, this accessor&#10; *  treats a *property* value of 'src' specially.&#10; *  Specifically, it appends to the *content* a suffix of the form '?count=*n*',&#10; *  where *n* is a unique number. This forces the user interface to retrieve the image&#10; *  from the server rather than use its cached version because the URI is&#10; *  different from that of the cached version. The server, on the other hand, ignores&#10; *  the parameter 'count' that has been appended to this URI and simply returns the&#10; *  updated image.&#10; *&#10; *  The way this accessor works on most hosts is that it starts a web server on localhost&#10; *  at the specified port that serves the specified web page and then instructs&#10; *  the system default browser to load the default page from that server.&#10; *  The page served by the server includes a script that listens for websocket&#10; *  connections that are used to provide HTML content and udpates to display on the page.&#10; *  Some hosts, however, such as the cordova and browser hosts, natively use&#10; *  a browser as part of the host, so in these cases, no web server nor socket&#10; *  connection is needed and the *port* parameter will be ignored.&#10; *  &#10; *  @accessor utilities/UserInterface.js&#10; *  @input {string} html HTML content to render in the body of the page displayed&#10; *   by the user interface.&#10; *  @input resources An object where each named property is an object containing&#10; *   two properties, 'data' and 'contentType'. The name of the named property is&#10; *   the path to be used to access the resource. The 'data' property is the resource&#10; *   itself, an arbitrary collection of bytes. The 'contentType' is the MIME&#10; *   type of the data.&#10; *  @input update An object with three properties, 'id', 'property', and 'content',&#10; *   that specifies an update to a DOM element on the page.&#10; *  @parameter {string} header HTML content to include in the header part of the web page.&#10; *   This is a good place to script definitions.&#10; *  @parameter {string} content HTML content to include in the main body of the page.&#10; *   If this is non-empty, then the page is opened upon initialize.&#10; *   Otherwise, the page is opened when the first *html* input is received.&#10; *  @parameter {int} port The port to use, if needed, for websocket communication between this&#10; *   accessor (which updates the HTML content of the web page) and the user interface.&#10; *   The web page will listen on this socket for content and display whatever arrives&#10; *   on that port. This is ignored on hosts that do not need to invoke an external browser.&#10; *  @author Edward A. Lee (eal@eecs.berkeley.edu)&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should be no&#10;// space between the / and the * and global. See https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*global error, exports, require, util */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;var UserInterface = require('@accessors-modules/user-interface');&#10;var userInterface = null;&#10;&#10;exports.setup = function () {&#10;    this.parameter('header', {&#10;        'type': 'string',&#10;        'value': ''&#10;    });&#10;    this.parameter('content', {&#10;        'type': 'string',&#10;        'value': ''&#10;    });&#10;    this.input('html', {&#10;        'type': 'string'&#10;    });&#10;    this.input('resources');&#10;    this.input('update', {&#10;        'type': 'JSON'&#10;    });&#10;    this.output('post', {&#10;        'type': 'JSON',&#10;        'spontaneous': true&#10;    });&#10;    // Use port 8089 because port 8080 is occupied on terra.eecs.berkeley.edu&#10;    this.parameter('port', {&#10;        'type': 'int',&#10;        'value': 8089&#10;    });&#10;};&#10;&#10;/** Display the HTML contents retrieved from the *html* input in the main body&#10; *  of the user interface page replacing whatever was there before.&#10; *  Before doing this, check for any *resources* input and add those resources&#10; *  to the user interface in case the HTML references them. &#10; */&#10;function display() {&#10;    // Check for any new resources.&#10;    var resources = this.get('resources');&#10;    if (resources) {&#10;        for (var name in resources) {&#10;            userInterface.addResource(name, resources[name].data, resources[name].contentType);&#10;        }&#10;    }&#10;&#10;    var toDisplay = this.get('html');&#10;    userInterface.display(toDisplay);&#10;}&#10;&#10;/** Update the specified property of the DOM element of the current page,&#10; *  if it exists, with the specified content.&#10; *  @param id The ID.&#10; *  @param property The type of the update. If this is &quot;html&quot;, then the&#10; *   DOM object is updated by invoking the jQuery html() function it&#10; *   with the specified content as an argument. Otherwise, the property&#10; *   with name *property* is assigned the value of the content.&#10; *   If *property* is 'src', then in addition, the content is augmented&#10; *   with a suffix of the form '?count=*n*', where *n* is a unique number.&#10; *   This is so that the user interface will be forced to reload the src rather than&#10; *   using any cached version it may have. This can be used, for example,&#10; *   to force an update to an img tag where a new image has been provided&#10; *   using addResource().&#10; *  @param content The content of the update, typically HTML to insert or&#10; *   a property value like src to set.&#10; */&#10;function update() {&#10;    var updateValue = this.get('update');&#10;    if (!updateValue.id || !updateValue.property) {&#10;        error('Malformed update input. Expected an object with id, property, and content properties.'&#10;                + 'Got instead: ' + util.inspect(updateValue));&#10;        return;&#10;    }&#10;    // Ensure that updateValue.content exists.&#10;    if (!updateValue.content) {&#10;        updateValue.content = '';&#10;    }&#10;    userInterface.update(updateValue.id, updateValue.property, updateValue.content);&#10;}&#10;&#10;exports.initialize = function () {&#10;    var self = this;&#10;    &#10;    userInterface = new UserInterface.UserInterface(&#10;            {'port': self.getParameter('port')},&#10;            self.getParameter('header'),&#10;            self.getParameter('content')&#10;    );&#10;    // Listen for any POST to the server.&#10;    userInterface.addListener('/', function(data) {&#10;        self.send('post', JSON.parse(data));&#10;    });&#10;&#10;    this.addInputHandler('html', display.bind(this));&#10;&#10;    this.addInputHandler('update', update.bind(this));&#10;&#10;    this.addInputHandler('resources', function() {&#10;        var resources = this.get('resources');&#10;        for (var name in resources) {&#10;            userInterface.addResource(name, resources[name].data, resources[name].contentType);&#10;        }&#10;    });&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (userInterface) {&#10;        userInterface.stop();&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/UserInterface.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor that provides a user interface based on HTML5 on the local host.&#10; The initial content on the page may be specified using the &lt;em&gt;content&lt;/em&gt;&#10; parameter and HTML header content may be specified using &lt;em&gt;header&lt;/em&gt;.&lt;/p&gt;&#10;&lt;p&gt; Whatever text is received on the &lt;em&gt;html&lt;/em&gt; input port will replace the content&#10; of the web page. Normally, this will be HTML text without any DOCTYPE or&#10; header and without a body tag. Each time new text is received, the content&#10; of the page will be replaced.&lt;/p&gt;&#10;&lt;p&gt; The page will be opened upon initialize if &lt;em&gt;content&lt;/em&gt; is not empty.&#10; Otherwise, it will be opened when the first &lt;em&gt;html&lt;/em&gt; input is received.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;resources&lt;/em&gt; input can be used to provide resources, such as images,&#10; that will be used by the HTML content provided on the &lt;em&gt;html&lt;/em&gt; input.&#10; Note that you probably will also have to provide an &lt;em&gt;update&lt;/em&gt; input (see below)&#10; to force the user interface to update the page using the specified resource.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;update&lt;/em&gt; input can be used to instruct the user interface to replace content&#10; within the page, vs. the &lt;em&gt;html&lt;/em&gt; input which replaces the entire page.&#10; The value of an &lt;em&gt;update&lt;/em&gt; input is expected to be an object with three properties,&#10; &lt;em&gt;id&lt;/em&gt;, &lt;em&gt;property&lt;/em&gt;, and &lt;em&gt;content&lt;/em&gt;.&lt;/p&gt;&#10;&lt;p&gt; The &lt;em&gt;id&lt;/em&gt; property refers to a the ID of&#10; a DOM element in the content of the page, where the content has been provided&#10; either via the &lt;em&gt;content&lt;/em&gt; parameter or the &lt;em&gt;html&lt;/em&gt; input. For example, your&#10; page may include:&#10; &lt;pre&gt;&#10;    &amp;lt;div id=&amp;quot;foo&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;&#10; &lt;/pre&gt;&#10; or&#10; &lt;pre&gt;&#10;    &amp;lt;img id=&amp;quot;bar&amp;quot; src=&amp;quot;image.jpg&amp;quot;/&amp;gt;&#10; &lt;/pre&gt;&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;p&gt;@param id The ID.&#10;The &lt;em&gt;property&lt;/em&gt; field specifies what property of the DOM element with the&#10;specified ID is to be updated. If &lt;em&gt;property&lt;/em&gt; is &amp;quot;html&amp;quot;, then the&#10;DOM object is updated by invoking the jQuery html() function&#10;with the specified &lt;em&gt;content&lt;/em&gt; as an argument. For example, if &lt;em&gt;id&lt;/em&gt; is &amp;quot;foo&amp;quot;,&#10;&lt;em&gt;property&lt;/em&gt; is &amp;quot;html&amp;quot;, and &lt;em&gt;content&lt;/em&gt; is &amp;quot;Hello World!&amp;quot;, then the above div&#10;will be populated with the text &amp;quot;Hello World!&amp;quot; on the web page.&#10;The &lt;em&gt;content&lt;/em&gt; can include any HTML markup or even scripts, which will be executed.&lt;/p&gt;&#10;&lt;p&gt;If &lt;em&gt;property&lt;/em&gt; is anything other than 'html', then the DOM element's &lt;em&gt;property&lt;/em&gt;&#10;attribute will be assigned the value of &lt;em&gt;content&lt;/em&gt;.&#10;A &lt;em&gt;property&lt;/em&gt; value of 'src', however, is treated specially.&#10;A &lt;em&gt;property&lt;/em&gt; value of 'src' can be used, for example, to replace the image in the above img tag.&#10;Just send the updated image to the &lt;em&gt;resources&lt;/em&gt; input and send this to the&#10;&lt;em&gt;update&lt;/em&gt; input:&lt;/p&gt;&#10;&lt;pre&gt;&#10;{'id':'bar', 'property':'src', 'content':'image.jpg'}&#10;&lt;/pre&gt;&#10;&#10;&lt;p&gt;Note that to get the user interface to actually replace the image, we may have to play some tricks.&#10;If the user interface is implemented by a browser, then the browser&#10;normally caches an image that it has previously retrieved&#10;and it will use the cached version of the image rather than obtaining the new image&#10;from the server.  To force the user interface to refresh the image, this accessor&#10;treats a &lt;em&gt;property&lt;/em&gt; value of 'src' specially.&#10;Specifically, it appends to the &lt;em&gt;content&lt;/em&gt; a suffix of the form '?count=&lt;em&gt;n&lt;/em&gt;',&#10;where &lt;em&gt;n&lt;/em&gt; is a unique number. This forces the user interface to retrieve the image&#10;from the server rather than use its cached version because the URI is&#10;different from that of the cached version. The server, on the other hand, ignores&#10;the parameter 'count' that has been appended to this URI and simply returns the&#10;updated image.&lt;/p&gt;&#10;&lt;p&gt;The way this accessor works on most hosts is that it starts a web server on localhost&#10;at the specified port that serves the specified web page and then instructs&#10;the system default browser to load the default page from that server.&#10;The page served by the server includes a script that listens for websocket&#10;connections that are used to provide HTML content and udpates to display on the page.&#10;Some hosts, however, such as the cordova and browser hosts, natively use&#10;a browser as part of the host, so in these cases, no web server nor socket&#10;connection is needed and the &lt;em&gt;port&lt;/em&gt; parameter will be ignored.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee (eal@eecs.berkeley.edu)">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="html (port)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to render in the body of the page displayed&#10;  by the user interface.">
            </property>
            <property name="resources (port)" class="ptolemy.kernel.util.StringAttribute" value="An object where each named property is an object containing&#10;  two properties, 'data' and 'contentType'. The name of the named property is&#10;  the path to be used to access the resource. The 'data' property is the resource&#10;  itself, an arbitrary collection of bytes. The 'contentType' is the MIME&#10;  type of the data.">
            </property>
            <property name="header (parameter)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to include in the header part of the web page.&#10;  This is a good place to script definitions.">
            </property>
            <property name="content (parameter)" class="ptolemy.kernel.util.StringAttribute" value="HTML content to include in the main body of the page.&#10;  If this is non-empty, then the page is opened upon initialize.&#10;  Otherwise, the page is opened when the first *html* input is received.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to use, if needed, for websocket communication between this&#10;  accessor (which updates the HTML content of the web page) and the user interface.&#10;  The web page will listen on this socket for content and display whatever arrives&#10;  on that port. This is ignored on hosts that do not need to invoke an external browser.">
            </property>
            <property name="update (port)" class="ptolemy.kernel.util.StringAttribute" value="An object with three properties, 'id', 'property', and 'content',&#10;  that specifies an update to a DOM element on the page.">
            </property>
            <property name="post (port)" class="ptolemy.kernel.util.StringAttribute">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[840.0, 165.0]">
        </property>
        <property name="header" class="ptolemy.data.expr.Parameter" value="&lt;title&gt;AugmentedReality Demo&lt;/title&gt;&#10;&lt;style&gt;&#10;#container {&#10;  position: relative;&#10;  background: black;&#10;  width: 1000px;&#10;  height: 600px;&#10;}&#10;#image {&#10;  display: block;&#10;}&#10;#image:hover {&#10;  opacity: 0.5;&#10;}&#10;#overlay {&#10;  position: absolute;&#10;  background-color: rgba(255,255,255,0.7);&#10;  color: black;&#10;  font-size: 12px;&#10;  font-family: sans-serif;&#10;  padding: 6px 6px;&#10;}&#10;table, th, td {&#10;  border: 1px solid black;&#10;  border-collapse: collapse;&#10;  padding: 2px;&#10;}&#10;&lt;/style&gt;&#10;">
            <property name="style" class="ptolemy.actor.gui.style.TextStyle">
                <property name="height" class="ptolemy.data.expr.Parameter" value="10">
                </property>
                <property name="width" class="ptolemy.data.expr.Parameter" value="30">
                </property>
            </property>
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="content" class="ptolemy.data.expr.Parameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <port name="html" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="resources" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="post" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="update" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
    </entity>
    <entity name="Clock" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Accessor that spontaneously produces outputs once per time interval.&#10;//&#10;// Copyright (c) 2015-2016 The Regents of the University of California.&#10;// All rights reserved.&#10;//&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;//&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;//&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;//&#10;&#10;/** Accessor that spontaneously produces outputs once per time interval.&#10; *  This implementation produces a counting sequence.&#10; *&#10; *  @accessor utilities/Clock&#10; *  @parameter interval The interval between outputs in milliseconds.&#10; *  @output output Output for the counting sequence, of type number.&#10; *  @author Edward A. Lee&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint.  Note that there should be no&#10;// space between the / and the * and global.&#10;/*globals clearInterval, exports, require, setInterval */&#10;/*jshint globalstrict: true*/&#10;&quot;use strict&quot;;&#10;&#10;exports.setup = function () {&#10;    this.parameter('interval', {&#10;        'type': 'number',&#10;        'value': 1000&#10;    });&#10;    this.output('output', {&#10;        'type': 'number'&#10;    });&#10;};&#10;&#10;// These variables will not be visible to subclasses.&#10;var handle = null;&#10;var count = 0;&#10;&#10;exports.initialize = function () {&#10;    count = 0;&#10;    // Need to record 'this' for use in the callback.&#10;    var thiz = this;&#10;&#10;    // Send an output and then call setInterval&#10;    thiz.send('output', count);&#10;    count += 1;&#10;    &#10;    handle = setInterval(function () {&#10;        thiz.send('output', count);&#10;        count += 1;&#10;    }, this.getParameter('interval'));&#10;};&#10;&#10;exports.wrapup = function () {&#10;    if (handle) {&#10;        clearInterval(handle);&#10;        handle = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/Clock.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor that spontaneously produces outputs once per time interval.&#10; This implementation produces a counting sequence.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" value="Output for the counting sequence, of type number.">
            </property>
            <property name="interval (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The interval between outputs in milliseconds.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="{25.0, 350.0}">
        </property>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Mutable" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function() {&#10;	this.extend('utilities/MutableBase');&#10;	this.implement('ControllableSensor');&#10;};">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/utilities/Mutable.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Template for mutable accessors. A mutable accessor is an accessor&#10; that does nothing until it is 'reified' by another accessor. Once&#10; reified, the reifying accessor will react to inputs to this mutable and&#10; produce outputs. The reifying accessor is required to be compatible with&#10; this instance of mutable. To be compatible, every input of the reifying&#10; accessor must have a matching input in this instance of mutable, and&#10; every output of this instance of mutable must have a matching output&#10; in the reifying accessor.&lt;/p&gt;&#10;&lt;p&gt; To use this, add interface information&#10; to the setup function that matches the interface that you require,&#10; and then provide on the &lt;em&gt;accessor&lt;/em&gt; input port the source code for&#10; accessors that you want to reify this mutable. E.g.:&lt;/p&gt;&#10;&lt;pre class=&quot;prettyprint source lang-javascript&quot;&gt;&lt;code&gt; exports.setup = function() {&#10;     this.extend('utilities/MutableBase');&#10;     ... add your inputs, outputs, and parameters here ...&#10; };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; A good way to add your inputs, outputs, and parameters is to define&#10; an interface and then implement it as follows:&lt;/p&gt;&#10;&lt;pre class=&quot;prettyprint source lang-javascript&quot;&gt;&lt;code&gt; exports.setup = function() {&#10;     this.extend('utilities/MutableBase');&#10;     this.implement('MyInterfaceDefinition');&#10; };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; Your interface definition should look something like this:&lt;/p&gt;&#10;&lt;pre class=&quot;prettyprint source lang-javascript&quot;&gt;&lt;code&gt; exports.setup = function() {&#10;     this.realize('MyOntologyConcept');&#10;     this.input('in');&#10;     this.output('out');&#10;  };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; This should be put into a file named MyInterfaceDefinition.js. If that&#10; file is in the same directory as the swarmlet that uses this Mutable, then&#10; the host will be able to find the file.&lt;/p&gt;&#10;&lt;p&gt; The call to realize() associates with the interface an ontology concept,&#10; which as of this writing is just an arbitrary string. Any accessor provided&#10; at the &lt;em&gt;accessor&lt;/em&gt; input must also realize this same ontology concept in order&#10; to be able to reify the mutable.  It must also have an input named 'in'&#10; and an output named 'out', since those are the inputs and outputs defined&#10; in this interface.  The accessor provided at the &lt;em&gt;accessor&lt;/em&gt; input could&#10; simply realize this same interface.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Chadlia Jerad and Edward A. Lee">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="accessor (port)" class="ptolemy.kernel.util.StringAttribute" value="Accessor code to reify.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="accessor" class="ptolemy.actor.parameters.PortParameter" value="">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[540.0, 295.0]">
        </property>
        <property name="control" class="ptolemy.actor.parameters.PortParameter" value="{}">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_localChanges" class="ptolemy.kernel.util.SingletonAttribute">
        </property>
        <port name="accessor" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
        </port>
        <port name="control" class="ptolemy.actor.parameters.ParameterPort">
            <property name="input"/>
            <property name="defaultValue" class="ptolemy.data.expr.Parameter">
            </property>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="data" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="schema" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
        <port name="state" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="TagToAccessor" class="ptolemy.actor.TypedCompositeActor">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[430.0, 250.0]">
        </property>
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={101, 219, 934, 632}, maximized=false}">
        </property>
        <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[700, 522]">
        </property>
        <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
        </property>
        <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{347.0, 426.873046875}">
        </property>
        <port name="tags" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{20.0, 240.0}">
            </property>
        </port>
        <port name="index" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{20.0, 280.0}">
            </property>
        </port>
        <port name="accessor" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{580.0, 200.0}">
            </property>
        </port>
        <port name="translation" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_showName" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{580.0, 240.0}">
            </property>
        </port>
        <entity name="DummyHostLocation" class="ptolemy.actor.lib.jjs.JavaScript">
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
            </property>
            <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
            </property>
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="//This is a dummy accessor (it already contains all the information it&#10;//&quot;accesses&quot;) that is supposed to be a placeholder for a location accessor&#10;//like RedPin that works at the room level. This accessor is supposed to&#10;//output the room depicted in the AR image &#10;&#10;&#10;//Name of the spatial ontology used in this model&#10;var spatialOntology = 'ARDemo';&#10;&#10;var location = spatialOntology + &quot;://&quot; + 'Berkeley/CoryHall/DOPCenter';&#10;&#10;exports.setup = function() {&#10;    //Inputs&#10;    this.input('trigger');&#10;    &#10;    //Outputs&#10;    this.output('location', {&#10;        'type': 'string'&#10;    });&#10;}&#10;&#10;exports.initialize = function() {&#10;    var thiz = this;&#10;    &#10;    this.addInputHandler('trigger' , function () {&#10;        thiz.send( 'location', location);&#10;    });&#10;}&#10;">
                <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                    <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                    </property>
                </property>
            </property>
            <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
                </property>
                <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[155.0, 355.0]">
            </property>
            <port name="trigger" class="ptolemy.actor.TypedIOPort">
                <property name="input"/>
            </port>
            <port name="location" class="ptolemy.actor.TypedIOPort">
                <property name="output"/>
            </port>
        </entity>
        <entity name="TagSelector" class="ptolemy.actor.lib.jjs.JavaScript">
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
            </property>
            <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
            </property>
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="var httpClient = require('@accessors-modules/http-client');&#10;&#10;var IdToResource = null;&#10;&#10;exports.setup = function() {&#10;    // Inputs&#10;    this.input('tags');&#10;    this.input('index', {&#10;        'type':'int', &#10;        'value':0&#10;    });&#10;    &#10;    // Outputs&#10;    this.output('tag', {&#10;        'type': 'int'&#10;    });&#10;    this.output('translation');&#10;}&#10;&#10;exports.initialize = function() {&#10;    var thiz = this;&#10;    var previousIndex = -1;&#10;    &#10;    &#10;    //Assume both the tags and index inputs always arrive simultaneously&#10;    this.addInputHandler('tags', function() {&#10;        var tags = thiz.get('tags');&#10;        var index = thiz.get('index');&#10;        &#10;        if (index != previousIndex) {&#10;            // Index has changed. Look up a new tag.&#10;            if (tags &amp;&amp; tags.length &gt; index) {&#10;                thiz.send('tag', tags[index].id);&#10;            }&#10;            previousIndex = index;&#10;        }&#10;        thiz.send('translation', tags[index].center);&#10;    });&#10;}&#10;&#10;">
                <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                    <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                    </property>
                </property>
            </property>
            <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
                </property>
                <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[285.0, 280.0]">
            </property>
            <property name="index" class="ptolemy.actor.parameters.PortParameter" value="0">
            </property>
            <port name="index" class="ptolemy.actor.parameters.ParameterPort">
                <property name="input"/>
                <property name="defaultValue" class="ptolemy.data.expr.Parameter">
                </property>
            </port>
            <port name="tags" class="ptolemy.actor.TypedIOPort">
                <property name="input"/>
            </port>
            <port name="tag" class="ptolemy.actor.TypedIOPort">
                <property name="output"/>
            </port>
            <port name="translation" class="ptolemy.actor.TypedIOPort">
                <property name="output"/>
            </port>
        </entity>
        <entity name="TagURIBuilder" class="ptolemy.actor.lib.jjs.JavaScript">
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
            </property>
            <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
            </property>
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="//One-off javascript accessor for constructing a tag URI. Once a location&#10;//has been given as input it will begin constructing tagURIs. Before then&#10;//this accessor will not react to tag inputs.&#10;&#10;var location = null;&#10;&#10;&#10;exports.setup = function() {&#10;    //Inputs&#10;    this.input('location', {&#10;        &quot;type&quot; : &quot;string&quot;&#10;    });&#10;    this.input('tag', {&#10;        &quot;type&quot; : &quot;int&quot;&#10;    });&#10;    &#10;    //Outputs&#10;    this.output('tagURI', {&#10;        &quot;type&quot; : &quot;string&quot;,&#10;        &quot;value&quot; : &quot;&quot;&#10;    });&#10;}&#10;&#10;exports.initialize = function() {&#10;    var thiz = this;&#10;    &#10;    this.addInputHandler('location' , function () {&#10;        location = thiz.get('location');&#10;    });&#10;    &#10;    this.addInputHandler('tag' , function () {&#10;        if(location){&#10;            var uri = location + &quot;/&quot; + thiz.get('tag');&#10;            thiz.send( 'tagURI', uri);&#10;        }&#10;    });&#10;}">
                <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                    <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                    </property>
                </property>
            </property>
            <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
                </property>
                <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[390.0, 370.0]">
            </property>
            <port name="location" class="ptolemy.actor.TypedIOPort">
                <property name="input"/>
            </port>
            <port name="tag" class="ptolemy.actor.TypedIOPort">
                <property name="input"/>
            </port>
            <port name="tagURI" class="ptolemy.actor.TypedIOPort">
                <property name="output"/>
            </port>
        </entity>
        <entity name="DummyTagURIMap" class="ptolemy.actor.lib.jjs.JavaScript">
            <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
            </property>
            <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
            </property>
            <property name="script" class="ptolemy.actor.parameters.PortParameter" value="//Dummy Accessor for an ontology map between tagURIs and accessors&#10;&#10;&#10;var httpClient = require('@accessors-modules/http-client');&#10;&#10;//A non-dummy implementation of this accessor would obtain this information&#10;//from some external source and then cache it locally.&#10;var IdToResource = {&#10;    'ARDemo://Berkeley/CoryHall/DOPCenter/127': 'PressureSensor.js',&#10;    'ARDemo://Berkeley/CoryHall/DOPCenter/435': 'VibrationSensor.js',&#10;    'ARDemo://Berkeley/CoryHall/DOPCenter/105': 'TemperatureSensor.js'  &#10;};&#10;&#10;exports.setup = function() {&#10;    // Inputs&#10;    this.input('tagURI', {&#10;        'type': 'string'&#10;    });&#10;    &#10;    // Outputs&#10;    this.output('accessor', {&#10;        'type': 'string',&#10;        'value': ''&#10;    });&#10;}&#10;&#10;exports.initialize = function() {&#10;    var thiz = this;&#10;    &#10;    this.addInputHandler('tagURI', function() {&#10;        var uri = thiz.get('tagURI');&#10;        &#10;        var accessor = getResource(IdToResource[uri], 2000);&#10;        if (accessor) {&#10;            thiz.send('accessor', accessor);&#10;        }&#10;    });&#10;}&#10;&#10;">
                <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                    <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                    </property>
                </property>
            </property>
            <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
                <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
                </property>
                <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
                </property>
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="[395.0, 205.0]">
            </property>
            <port name="tagURI" class="ptolemy.actor.TypedIOPort">
                <property name="input"/>
            </port>
            <port name="accessor" class="ptolemy.actor.TypedIOPort">
                <property name="output"/>
            </port>
        </entity>
        <relation name="relation3" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation4" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation5" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation6" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation7" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        </relation>
        <relation name="relation" class="ptolemy.actor.TypedIORelation">
            <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
            </property>
            <vertex name="vertex1" value="{155.0, 260.0}">
            </vertex>
        </relation>
        <link port="tags" relation="relation"/>
        <link port="index" relation="relation3"/>
        <link port="accessor" relation="relation8"/>
        <link port="translation" relation="relation6"/>
        <link port="DummyHostLocation.trigger" relation="relation"/>
        <link port="DummyHostLocation.location" relation="relation4"/>
        <link port="TagSelector.index" relation="relation3"/>
        <link port="TagSelector.tags" relation="relation"/>
        <link port="TagSelector.tag" relation="relation5"/>
        <link port="TagSelector.translation" relation="relation6"/>
        <link port="TagURIBuilder.location" relation="relation4"/>
        <link port="TagURIBuilder.tag" relation="relation5"/>
        <link port="TagURIBuilder.tagURI" relation="relation7"/>
        <link port="DummyTagURIMap.tagURI" relation="relation7"/>
        <link port="DummyTagURIMap.accessor" relation="relation8"/>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[205.0, 350.0]">
        </vertex>
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
        <property name="width" class="ptolemy.data.expr.Parameter" value="-1">
        </property>
        <vertex name="vertex1" value="[340.0, 240.0]">
        </vertex>
    </relation>
    <relation name="relation16" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[640.0, 350.0]">
        </vertex>
    </relation>
    <relation name="relation11" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[630.0, 305.0]">
        </vertex>
    </relation>
    <relation name="relation12" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[460.0, 385.0]">
        </vertex>
    </relation>
    <relation name="relation13" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[355.0, 385.0]">
        </vertex>
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation14" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="ObjectRecognizer.input" relation="relation"/>
    <link port="ObjectRecognizer.tags" relation="relation3"/>
    <link port="ImageReader.output" relation="relation"/>
    <link port="ImageReader.trigger" relation="relation16"/>
    <link port="IndexGenerator.tags" relation="relation3"/>
    <link port="IndexGenerator.reset" relation="relation6"/>
    <link port="IndexGenerator.index" relation="relation4"/>
    <link port="IndexGenerator.next" relation="relation13"/>
    <link port="ConstructUI.reset" relation="relation6"/>
    <link port="ConstructUI.translate" relation="relation14"/>
    <link port="ConstructUI.data" relation="relation2"/>
    <link port="ConstructUI.html" relation="relation7"/>
    <link port="ConstructUI.resources" relation="relation8"/>
    <link port="ConstructUI.update" relation="relation9"/>
    <link port="ConstructUI.spec" relation="relation11"/>
    <link port="ConstructUI.image" relation="relation10"/>
    <link port="UserInterface.html" relation="relation7"/>
    <link port="UserInterface.resources" relation="relation8"/>
    <link port="UserInterface.post" relation="relation12"/>
    <link port="UserInterface.update" relation="relation9"/>
    <link port="Clock.output" relation="relation16"/>
    <link port="Mutable.accessor" relation="relation5"/>
    <link port="Mutable.control" relation="relation12"/>
    <link port="Mutable.data" relation="relation2"/>
    <link port="Mutable.schema" relation="relation11"/>
    <link port="TagToAccessor.tags" relation="relation3"/>
    <link port="TagToAccessor.index" relation="relation4"/>
    <link port="TagToAccessor.accessor" relation="relation5"/>
    <link port="TagToAccessor.translation" relation="relation14"/>
    <link relation1="relation" relation2="relation10"/>
    <link relation1="relation12" relation2="relation13"/>
</entity>
