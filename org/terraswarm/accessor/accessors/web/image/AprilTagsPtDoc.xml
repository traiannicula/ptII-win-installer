<property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
    <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee (eal@eecs.berkeley.edu)">
    </property>
    <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Accessor to detect AprilTags in an image or stream of images.&#10;An AprilTag is a pattern of dark and light squares similar to a QR code but easier for&#10;cameras to detect robustly and at a distance.&#10;AprilTags were created by Associate Professor Edwin Olson (&lt;a href=&quot;mailto:ebolson@umich.edu&quot;&gt;ebolson@umich.edu&lt;/a&gt;),&#10;EECS, University of Michigan. See &lt;a href=&quot;https://april.eecs.umich.edu/#in_browser&quot;&gt;https://april.eecs.umich.edu/&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt;The implementation of this accessor on the Ptolemy II/Nashorn accessor host&#10;uses an older Java implementation of the AprilTags detector written by Edwin Olson&#10;and more recently supplanted by a C version that performs much better. But this Java&#10;version is more easily included in Ptolemy II in a portable way. If you need better&#10;performance, consider replacing this with the C implementation and using JNI to interface&#10;to Ptolemy II.&lt;/p&gt;&#10;&lt;p&gt;https://april.eecs.umich.edu/software/apriltag.html contains a set of&#10;pregenerated tags as png and PostScript files.  However, these are of&#10;low resolution.  To scale them, use linear interpolation to avoid blurring.&#10;For example, with ImageMagik, use:&lt;/p&gt;&#10;&lt;p&gt; mogrify -scale 1000x1000 &lt;em&gt;.png; convert &lt;/em&gt;.png tag36h11.pdf&lt;/p&gt;&#10;&lt;p&gt;Or, search the web for &amp;quot;tag 36H11&amp;quot;.  &lt;/p&gt;&#10;&lt;p&gt;In the Ptolemy tree, a sample file may be found at&#10;$PTII/ptolemy/actor/lib/jjs/modules/aprilTags//demo/AprilTags/tag36_11_00586.pdf&lt;/p&gt;&#10;&lt;p&gt;The input to this accessor is an image or a stream of images, e.g. from the Camera&#10;accessor.  There are two outputs. The one named &lt;em&gt;output&lt;/em&gt; is a modified version&#10;of the input image that outlines any detected AprilTags in the image&#10;and indicates their center and ID.  The &lt;em&gt;tags&lt;/em&gt; output is an array of&#10;objects representing the detected tags. Each object includes the following fields:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;_id_: The ID of the detected tag.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;center&lt;/em&gt;: An array with two doubles giving the center of the tag in pixel coordinates.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;perimeter&lt;/em&gt;: An array with four arrays, each of which gives the x and y coordinates of&#10;a corner of the AprilTag.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt;The AprilTags detector has a large number of parameters that can be tuned via&#10;the &lt;em&gt;options&lt;/em&gt; input. To set an option, provide a JSON object with a field matching&#10;the option name.  The options are described below using descriptions provided by&#10;by Edwin Olson in his Java implementation of an AprilTag detector:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;em&gt;MagThresh&lt;/em&gt;: When growing components, the intra component variation is&#10;allowed to grow when the component is small in size. This&#10;threshold affects how much. The default is 1200.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;MaxEdgeCost&lt;/em&gt;: Set the maximum angle range allowed for the gradient directions&#10;when connecting edges, in radians. This defaults to the radian&#10;equivalent of 30 degrees.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;MinMag&lt;/em&gt;: Set the gradient magnitude threshold for ignoring pixels.&#10;Do not consider pixels whose gradient magnitude is less than&#10;minMag. Small values make the detector more sensitive, but also&#10;force us to consider many more edges resulting in slower&#10;computation time. A value of 0.001 is very sensitive. A value&#10;of 0.01 is quite fast. The default is 0.004.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;SegDecimate&lt;/em&gt;: Set whether decimating before segmenting is enabled.&#10;Instead of blurring the input image before segmentation, we&#10;can achieve similar effects by decimating the image by a factor&#10;of two. When enabled, this option applies a block LPF filter of&#10;width 2, then decimates the image. With this option, not only&#10;can we safely set segSigma = 0, but the slowest part of the&#10;algorithm (the segmentation) runs about 4 times faster. The&#10;downside is that the position of the targets is determined&#10;based on the segmentation: lower resolution will result in more&#10;localization error. However, the effect on quality is quite&#10;modest, and this optimization is generally recommended (along&#10;with segSigma = 0). If segSigma is non-zero, the filtering by&#10;segSigma occurs first, followed by the block LPF, and the&#10;decimation. This defaults to false, indicating that the option&#10;is not enabled.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;SegSigma&lt;/em&gt;: Set the Gaussian smoothing kernel applied to image (0 == no filter)&#10;used when detecting the outline of the box. It is almost always&#10;useful to have some filtering, since the loss of small details&#10;won&apos;t hurt. Recommended value = 0.8 (the default). The case where sigma ==&#10;segsigma has been optimized to avoid a redundant filter&#10;operation.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;Sigma&lt;/em&gt;: Set the Gaussian smoothing kernel applied to image (0 == no filter, the default)&#10;used when sampling bits. Filtering is a good idea in cases&#10;where A) a cheap camera is introducing artifical sharpening, B)&#10;the bayer pattern is creating artifcats, C) the sensor is very&#10;noisy and/or has hot/cold pixels. However, filtering makes it&#10;harder to decode very small tags. Reasonable values are 0, or&#10;[0.8, 1.5].&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;TagFamily&lt;/em&gt;: Set the name of the tag family being detected.&#10;This defaults to &amp;quot;Tag36h11&amp;quot;.&#10;The supported families are &amp;quot;Tag16h5&amp;quot;, &amp;quot;Tag25h7&amp;quot;, &amp;quot;Tag25h9&amp;quot;, &amp;quot;Tag36h10&amp;quot;, and &amp;quot;Tag36h11&amp;quot;.&#10;The default family seems least susceptible to false positives.&lt;/li&gt;&#10;&lt;li&gt;&lt;em&gt;ThetaThresh&lt;/em&gt;: When growing components, the intra component variation is&#10;allowed to grow when the component is small in size. This&#10;threshold affects how much. The default is 100.&lt;/li&gt;&#10;&lt;/ul&gt;">
    </property>
    <property name="input (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="An input image.">
    </property>
    <property name="output (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="An output image, with detected AprilTags outlined in green and identified.">
    </property>
    <property name="tags (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="An array of objects, one object for each tag detected in the image.">
    </property>
    <property name="options (parameter)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The options for the detector. This is a JSON object with fields defined above.&#10;  It defaults to an empty object, meaning to use default values for all the otpions.">
    </property>
    <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
    </property>
</property>