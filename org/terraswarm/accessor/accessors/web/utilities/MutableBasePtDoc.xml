<property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
    <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Chadlia Jerad and Edward A. Lee">
    </property>
    <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;Base class for mutable accessors. A mutable accessor is an accessor&#10; that does nothing until it is &apos;reified&apos; by another accessor. Once&#10; reified, the reifying accessor will react to inputs to this mutable and&#10; produce outputs. No particular combatibility rules are imposed to the&#10; reifying accessor. reify() will look for matching input and outputs &#10; between the reifying accessor and the instance of mutable&lt;/p&gt;&#10;&lt;p&gt; This base class defines an &lt;em&gt;accessor&lt;/em&gt; input that accepts an accessor&#10; instance, an accessor code (as string) or a fully qulified accessor&#10; class. The mutable reifies itself with the instance of the accessor, &#10; even no matching is found. This base class defines also a &lt;em&gt;state&lt;/em&gt;&#10; output. The mutable will be sending on this output a boolean value, &#10; that indicates if the reification succeeded or not. For example, if the &#10; received accessor cannot be resolved to an accessor instance, then &#10; false value will be sent on &apos;state&apos; output. To use this, extend it as&#10; follows:&lt;/p&gt;&#10;&lt;pre class=&quot;prettyprint source lang-javascript&quot;&gt;&lt;code&gt; exports.setup = function() {&#10;     this.extend(&apos;utilities/MutableBase&apos;);&#10;     ... add your inputs, outputs, and parameters here ...&#10; };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; A good way to add your inputs, outputs, and parameters is to define&#10; an interface and then implement it as follows:&lt;/p&gt;&#10;&lt;pre class=&quot;prettyprint source lang-javascript&quot;&gt;&lt;code&gt; exports.setup = function() {&#10;     this.extend(&apos;utilities/MutableBase&apos;);&#10;     this.implement(&apos;MyInterfaceDefinition&apos;);&#10; };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; Your interface definition should look something like this:&lt;/p&gt;&#10;&lt;pre class=&quot;prettyprint source lang-javascript&quot;&gt;&lt;code&gt; exports.setup = function() {&#10;     this.input(&apos;in&apos;);&#10;     this.output(&apos;out&apos;);&#10;  };&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; This should be put into a file named MyInterfaceDefinition.js. If that&#10; file is in the same directory as the swarmlet that uses this Mutable, then&#10; the host will be able to find the file.&lt;/p&gt;&#10;&lt;p&gt; If a null or empty string input is provided on &lt;em&gt;accessor&lt;/em&gt; and this mutable&#10; has been reified, then it will be unreified.&lt;/p&gt;">
    </property>
    <property name="accessor (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="Accessor instance, code or class to reify.">
    </property>
    <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
    </property>
</property>