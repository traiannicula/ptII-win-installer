<property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
    <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Hokeun Kim, Marcus Pan, Edward A. Lee, Matt Weber">
    </property>
    <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a web socket at&#10; the specified host and port.&#10; &lt;a href=&quot;https://en.wikipedia.org/wiki/WebSocket&quot;&gt;WebSockets&lt;/a&gt;&#10; provide full-duplex communication channels over a single TCP/IP connection.&#10; In &lt;code&gt;initialize()&lt;/code&gt;, it  begins connecting to the web socket server.&#10; Once the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output.&#10; If connection is not established immediately, the accessor will attempt to&#10; reconnect &lt;em&gt;numberOfRetries&lt;/em&gt; times at an interval of &lt;em&gt;reconnectInterval&lt;/em&gt;.&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt;&#10; input, the message is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when the socket opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded. If messages are queued and &lt;code&gt;throttleFactor&lt;/code&gt; is non-zero, then&#10; whenever a message is queued to be later sent, the accessor&apos;s input handler will stall&#10; by a number of milliseconds given by the queue size times the throttleFactor.&#10; The longer the queue, the longer the stall. Note that this will likely block&#10; the host from executing, so this feature should be used with caution.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;&apos;received&apos;&lt;/code&gt; output. Note that the message may actually be sent&#10; over multiple &apos;frames&apos;, but the frames will be aggregated and produced as one&#10; message.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the&#10; connection.&lt;/p&gt;&#10;&lt;p&gt; If the connection is dropped midway, the swarmlet may monitor the &apos;connected&apos;&#10; output for a value &apos;false&apos; and attempt a reconnection by providing either a&#10; port or server input.&lt;/p&gt;&#10;&lt;p&gt; The default type for both sending and receiving&#10; is &apos;application/json&apos;, which allows sending and receiving anything that has&#10; a string representation in JSON. The types supported by this implementation&#10; include at least:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;application/json&lt;/strong&gt;: The this.send() function uses JSON.stringify() and sends the&#10;result with a UTF-8 encoding. An incoming byte stream will be parsed as JSON,&#10;and if the parsing fails, will be provided as a string interpretation of the byte&#10;stream.&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;text/*&lt;/strong&gt;: Any text type is sent as a string encoded in UTF-8.&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;&lt;strong&gt;image/x&lt;/strong&gt;: Where &lt;strong&gt;x&lt;/strong&gt; is one of &lt;strong&gt;json&lt;/strong&gt;, &lt;strong&gt;png&lt;/strong&gt;, &lt;strong&gt;gif&lt;/strong&gt;,&#10;and more.&#10;In this case, the data passed to this.send() is assumed to be an image, as encoded&#10;on the host, and the image will be encoded as a byte stream in the specified&#10;format before sending.  A received byte stream will be decoded as an image,&#10;if possible.&lt;/p&gt;&#10;&lt;p&gt;When a model with an instance of this accessor stops executing, there&#10;are two mechanisms by which data in transit can be lost. In both cases, warning&#10;messages or error messages will be issued to the host to be displayed or otherwise&#10;handled as the host sees fit.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;li&gt;&lt;p&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/p&gt;&#10;&lt;p&gt;The server might similarly lose messages by the same two mechanisms occurring&#10;on the server side. In that case, messages will presumably be displayed on the&#10;server side.&lt;/p&gt;&#10;&lt;p&gt;Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10;to customize what is sent. See &lt;code&gt;RosPublisher.js&lt;/code&gt; for an example.&lt;/p&gt;&#10;&lt;p&gt;This accessor requires the &apos;webSocket&apos; module.&lt;/p&gt;&#10;&lt;/li&gt;&#10;&lt;/ul&gt;">
    </property>
    <property name="server (port)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The IP address or domain name of server. Defaults to &apos;localhost&apos;.">
    </property>
    <property name="port (port)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The port on the server to connect to. Defaults to -1, which means&#10;  wait for a non-negative input before connecting.">
    </property>
    <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The data to be sent over the socket.">
    </property>
    <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Output `true` on connected and `false` on disconnected.">
    </property>
    <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The data received from the web socket server.">
    </property>
    <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The MIME type for incoming messages,&#10;  which defaults to &apos;application/json&apos;.">
    </property>
    <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The MIME type for outgoing messages,&#10;  which defaults to &apos;application/json&apos;.">
    </property>
    <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The time in milliseconds to wait&#10;  before giving up on a connection (default is 1000).">
    </property>
    <property name="numberOfRetries (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The number of times to retry if&#10;  a connection fails. Defaults to 5.">
    </property>
    <property name="timeBetweenRetries (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The time between retries in milliseconds.&#10;  Defaults to 500.">
    </property>
    <property name="trustAll (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Whether to trust any server certificate.&#10;  This defaults to false. Setting it to true means that if sslTls is set to true,&#10;  then any certificate provided by the server will be trusted.">
    </property>
    <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If sslTls is set to true and trustAll is set to false,&#10;  then this option needs to specify the fully qualified filename for the file that stores&#10;  the certificate of a certificate authority (CA) that this client will use to verify server&#10;  certificates. This path can be any of those understood by the Ptolemy host, e.g. paths&#10;  beginning with $CLASSPATH/.&#10;  FIXME: Need to be a list of paths for certificates rather than a single path.">
    </property>
    <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Whether SSL/TLS is enabled. This defaults to false.">
    </property>
    <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If true,&#10;  then any messages received on `toSend` before the socket&#10;  is open will be discarded. This defaults to false.">
    </property>
    <property name="throttleFactor (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If non-zero, specifies a&#10;  time (in milliseconds) to stall when a message is queued&#10;  because the socket is not yet open. The time of the stall&#10;  will be the queue size (after adding the message) times&#10;  the throttleFactor. This defaults to 100. Making it non-zero&#10;  causes the input handler to take time if there are pending unsent messages.">
    </property>
    <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
    </property>
</property>