<property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
    <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim, Contributor: Matt Weber">
    </property>
    <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor sends and/or receives messages from a TCP socket at&#10; the specified host and port. If the value of the &lt;code&gt;port&lt;/code&gt; input is initially&#10; negative, then this accessor waits until it receives a non-negative &lt;code&gt;port&lt;/code&gt;&#10; input before making a connection. Otherwise,&#10; upon initialization, it initiates a connection to the&#10; specified server. If at any time during execution it receives&#10; a &apos;port&apos; input, then it will close any open socket and, if the new&#10; &apos;port&apos; value is non-negative, open&#10; a new socket to the current &apos;host&apos; and &apos;port&apos;.&lt;/p&gt;&#10;&lt;p&gt; When the connection is established, a &lt;code&gt;true&lt;/code&gt; boolean is sent to&#10; the &lt;code&gt;connected&lt;/code&gt; output. If the connection is broken during execution, then a &lt;code&gt;false&lt;/code&gt;&#10; boolean is sent to the &lt;code&gt;connected&lt;/code&gt; output. The swarmlet could respond to this by&#10; retrying to connect (send an event to either the &lt;code&gt;port&lt;/code&gt; or &lt;code&gt;host&lt;/code&gt; input).&lt;/p&gt;&#10;&lt;p&gt; Whenever an input is received on the &lt;code&gt;toSend&lt;/code&gt; input,&#10; the data on that input is sent to the socket. If the socket is not yet open,&#10; this accessor will, by default, queue the message to send when a socket next opens,&#10; unless the &lt;code&gt;discardMessagesBeforeOpen&lt;/code&gt; parameter is true, in which case,&#10; input messages that are received before the socket is opened will be&#10; discarded.&lt;/p&gt;&#10;&lt;p&gt; Whenever a message is received from the socket, that message is&#10; produced on the &lt;code&gt;received&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the  connection.&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least &apos;string&apos;, &apos;number&apos;, &apos;image&apos;, and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the &apos;number&apos; data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as &apos;float&apos; or &apos;int&apos;, if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript &apos;number&apos; when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type &apos;number&apos; is equivalent&#10; to &apos;double&apos;.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; &lt;a href=&quot;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3&quot;&gt;https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3&lt;/a&gt;.&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array all at once by providing an&#10; array to the &lt;code&gt;toSend&lt;/code&gt; input port.&#10; The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item provided on &lt;code&gt;toSend&lt;/code&gt;,&#10; of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; The server might similarly lose messages by the same two mechanisms occurring&#10; on the server side. In that case, messages will presumably be displayed on the&#10; server side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the &apos;socket&apos; module.&lt;/p&gt;">
    </property>
    <property name="host (port)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The IP address or domain name of server. Defaults to &apos;localhost&apos;.">
    </property>
    <property name="port (port)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The port on the server to connect to. Defaults to -1, which means&#10;  wait for a non-negative input before connecting.">
    </property>
    <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The data to be sent over the socket.">
    </property>
    <property name="connected (port)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Output `true` on connected and `false` on disconnected.">
    </property>
    <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The data received from the web socket server.">
    </property>
    <property name="connectTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The time to wait (in milliseconds) before declaring&#10;   a connection attempt to have failed. This defaults to 6000.">
    </property>
    <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
    </property>
    <property name="discardMessagesBeforeOpen (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If true, then discard any messages&#10;   passed to SocketClient.send() before the socket is opened. If false,&#10;   then queue the messages to be sent when the socket opens. This&#10;   defaults to false.">
    </property>
    <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
    </property>
    <property name="maxUnsentMessages (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The maximum number of unsent messages to queue before&#10;   further calls to this.send() will fail. A value of 0 means no limit.&#10;   This defaults to 100.">
    </property>
    <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If true, data as sent as soon as it is available (the default).&#10;   If false, data may be accumulated until a reasonable packet size is formed&#10;   in order to make more efficient use of the network (using Nagle&apos;s algorithm).">
    </property>
    <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the password for the pfx key-cert&#10;   file specified by pfxKeyCertPath.">
    </property>
    <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If sslTls is set to true and the server requires&#10;   client authentication, then this option needs to specify the fully qualified filename for&#10;   the file that stores the private key and certificate that this client will use to authenticate&#10;   itself to the server. This path can be any of those understood by the Ptolemy host,&#10;   e.g. paths beginning with $CLASSPATH/.">
    </property>
    <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If true (the default), then transmit only the data bytes provided&#10;   to this.send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   this.send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
    </property>
    <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The size of the receive buffer. Defaults to&#10;   65536.">
    </property>
    <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="See above.">
    </property>
    <property name="reconnectAttempts (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The number of times to try to reconnect.&#10;   If this is greater than 0, then a failure to attempt will trigger&#10;   additional attempts. This defaults to 10.">
    </property>
    <property name="reconnectInterval (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The time between reconnect attempts, in&#10;   milliseconds. This defaults to 1000 (1 second).">
    </property>
    <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The size of the receive buffer. Defaults to&#10;   65536.">
    </property>
    <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="See above.">
    </property>
    <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Whether SSL/TLS is enabled. This defaults to false.">
    </property>
    <property name="trustAll (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Whether to trust servers. This defaults to false.&#10;   Setting it to true means that if sslTls is set to true, then&#10;   any certificate provided by the server will be trusted.&#10;   FIXME: Need to provide a trusted list if this is false.">
    </property>
    <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If sslTls is set to true and trustAll is&#10;   set to false, then this option needs to specify the fully qualified filename&#10;   for the file that stores the certificate of a certificate authority (CA) that&#10;   this client will use to verify server certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
    </property>
    <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
    </property>
</property>