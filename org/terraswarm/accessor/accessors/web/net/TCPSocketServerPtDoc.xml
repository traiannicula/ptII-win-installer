<property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
    <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee, Hokeun Kim">
    </property>
    <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor establishes a server that can accept connection requests for&#10; a TCP socket and can send and/or receives messages from the client that makes the&#10; request.&lt;/p&gt;&#10;&lt;p&gt; When the server is listening and accepting connections, the port on which it is&#10; listening is emitted on the &lt;code&gt;listening&lt;/code&gt; output port.&lt;/p&gt;&#10;&lt;p&gt; When a connection is established, this accessor outputs on the &lt;code&gt;connection&lt;/code&gt; output&#10; an object with the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;&lt;strong&gt;id&lt;/strong&gt;: A unique ID identifying the connection (a positive integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remoteHost&lt;/strong&gt;: The IP address of the remote host for the socket (a string).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;remotePort&lt;/strong&gt;: The port of the remote host for the socket (an integer).&lt;/li&gt;&#10;&lt;li&gt;&lt;strong&gt;status&lt;/strong&gt;: The string &apos;open&apos;.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; When the connection is closed, the same object as above is produced on the&#10; &lt;code&gt;connection&lt;/code&gt; output, except with status being &apos;closed&apos;.&lt;/p&gt;&#10;&lt;p&gt; When data is received from the connection, two outputs are produced.&#10; The data itself is produced on the &lt;code&gt;received&lt;/code&gt; output.  The ID of the connection&#10; over which the data arrived is produced on the &lt;code&gt;receivedID&lt;/code&gt; output.&lt;/p&gt;&#10;&lt;p&gt; To send data over a connection, provide the data on the &lt;code&gt;toSend&lt;/code&gt; input port&#10; and the ID of the connection on the &lt;code&gt;toSendID&lt;/code&gt; input port.  To send to all open&#10; connections, provide an ID of 0 (zero).&lt;/p&gt;&#10;&lt;p&gt; The send and receive types can be any of those supported by the host.&#10; The list of supported types will be provided as options for the &lt;code&gt;sendType&lt;/code&gt;&#10; and &lt;code&gt;receiveType&lt;/code&gt; parameter. For the Ptolemy II host, these include at&#10; least &apos;string&apos;, &apos;number&apos;, &apos;image&apos;, and a variety of numeric types.&lt;/p&gt;&#10;&lt;p&gt; If both ends of the socket are known to be JavaScript clients,&#10; then you should use the &apos;number&apos; data type for numeric data.&#10; If one end or the other is not JavaScript, then&#10; you can use more specified types such as &apos;float&apos; or &apos;int&apos;, if they&#10; are supported by the host. In all cases, received numeric&#10; data will be converted to JavaScript &apos;number&apos; when emitted.&#10; For sent data, this will try to convert a JavaScript number&#10; to the specified type. The type &apos;number&apos; is equivalent&#10; to &apos;double&apos;.&lt;/p&gt;&#10;&lt;p&gt; When type conversions are needed, e.g. when you send a double&#10; with &lt;code&gt;sendType&lt;/code&gt; set to int, or an int with &lt;code&gt;sendType&lt;/code&gt; set to byte,&#10; then a &amp;quot;primitive narrowing conversion&amp;quot; will be applied, as specified here:&#10; https://docs.oracle.com/javase/specs/jls/se8/html/jls-5.html#jls-5.1.3 .&lt;/p&gt;&#10;&lt;p&gt; For numeric types, you can also send an array with a single call&#10; to this.send(). The elements of the array will be sent in sequence all&#10; at once, and may be received in one batch. If both ends have&#10; &lt;code&gt;rawBytes&lt;/code&gt; set to false (specifying message framing), then these&#10; elements will be emitted at the receiving end all at once in a single&#10; array. Otherwise, they will be emitted one at a time.&lt;/p&gt;&#10;&lt;p&gt; For strings, you can also send an array of strings in a single call,&#10; but these will be simply be concatenated and received as a single string.&lt;/p&gt;&#10;&lt;p&gt; If the &lt;code&gt;rawBytes&lt;/code&gt; option is set to false, then each data item that arrives on&#10; &lt;code&gt;toSend&lt;/code&gt;, of any type or array of types, will be coalesced into a single message and&#10; the receiving end (if it also has &lt;code&gt;rawBytes&lt;/code&gt; set to false) will emit the entire&#10; message, and only the message, exactly once.  Otherwise, a message may get&#10; fragmented, emitted in pieces, or coalesced with subsequent messages.&lt;/p&gt;&#10;&lt;p&gt; When a model with an instance of this accessor stops executing, there&#10; are two mechanisms by which data in transit can be lost. In both cases, warning&#10; messages or error messages will be issued to the host to be displayed or otherwise&#10; handled as the host sees fit.&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;First, there might be queued messages that were received on &lt;code&gt;toSend&lt;/code&gt; but have not yet&#10;been sent, either because the socket has not yet been opened or because&#10;it was closed from the other side.&lt;/li&gt;&#10;&lt;li&gt;Second, a message might be received from the server after shutdown has commenced.&#10;In particular, received messages are handled asynchronously by a handler function&#10;that can be invoked at any time, and that handler might be invoked after it is no&#10;longer possible for this accessor to produce outputs (it has entered its wrapup&#10;phase of execution).&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; The client might similarly lose messages by the same two mechanisms occurring&#10; on the client side. In that case, messages will presumably be displayed on the&#10; client side.&lt;/p&gt;&#10;&lt;p&gt; Accessors that extend this one can override the &lt;code&gt;toSendInputHandler&lt;/code&gt; function&#10; to customize what is sent.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the &apos;socket&apos; module.&lt;/p&gt;">
    </property>
    <property name="toSend (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The data to be sent over the socket.">
    </property>
    <property name="toSendID (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The ID of the connection over which to send the data, where 0 means&#10;   to send to all open connections.">
    </property>
    <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on&#10;   (this is useful if the port is specified to be 0).">
    </property>
    <property name="connection (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="Output an object with the properties specified above when a&#10;    connection is established.">
    </property>
    <property name="received (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The data received from the web socket server.">
    </property>
    <property name="receivedID (port)" class="ptolemy.kernel.util.StringAttribute" type="undefined" value="The ID of the connection over which data produced on the received&#10;   output was received. This is a positive integer, as indicated in the connection&#10;   output.">
    </property>
    <property name="clientAuth (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="One of &apos;none&apos;, &apos;request&apos;, or &apos;required&apos;, meaning&#10;   whether it requires that a certificate be presented.">
    </property>
    <property name="discardSendToUnopenedSocket (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If true, then discard any data&#10;  sent to a socket that is not open. The data will be logged using console.log()&#10;  instead. This defaults to false.">
    </property>
    <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The name of the network interface to use for&#10;   listening, e.g. &apos;localhost&apos;. The default is &apos;0.0.0.0&apos;, which means to&#10;   listen on all available interfaces.">
    </property>
    <property name="idleTimeout (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The amount of idle time in seconds that will cause&#10;   a disconnection of a socket. This defaults to 0, which means no&#10;   timeout.">
    </property>
    <property name="keepAlive (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Whether to keep a connection alive and reuse it. This&#10;   defaults to true.">
    </property>
    <property name="noDelay (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If true, data as sent as soon as it is available&#10;   (the default). If false, data may be accumulated until a reasonable packet size is&#10;   formed in order to make more efficient use of the network (using Nagle&apos;s algorithm).">
    </property>
    <property name="pfxKeyCertPassword (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If sslTls is set to true, then this option&#10;   needs to specify the password for the pfx key-cert file specified by pfxKeyCertPath.">
    </property>
    <property name="pfxKeyCertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If sslTls is set to true, then this option&#10;   needs to specify the fully qualified filename for the file that stores the&#10;   private key and certificate that this server will use to identify itself. This path can be&#10;   any of those understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.">
    </property>
    <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The default port to listen on. This defaults to 4000.&#10;   a value of 0 means to choose a random ephemeral free port.">
    </property>
    <property name="rawBytes (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If true (the default), then transmit only the data bytes provided&#10;   to this.send() without any header. If false, then prepend sent data with length&#10;   information and assume receive data starts with length information.&#10;   Setting this false on both ends will ensure that each data item passed to&#10;   this.send() is emitted once in its entirety at the receiving end, as a single&#10;   message. When this is false, the receiving end can emit a partially received&#10;   message or could concatenate two messages and emit them together.">
    </property>
    <property name="receiveBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The size of the receive buffer. Defaults to&#10;   65536.">
    </property>
    <property name="receiveType (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="See below.">
    </property>
    <property name="sendBufferSize (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="The size of the receive buffer. Defaults to&#10;   65536.">
    </property>
    <property name="sendType (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="See below.">
    </property>
    <property name="sslTls (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="Whether SSL/TLS is enabled. This defaults to false.">
    </property>
    <property name="trustedCACertPath (parameter)" class="ptolemy.kernel.util.StringAttribute" type="[object Object]" value="If sslTls is set to true and this server&#10;   requests/requires a certificate from the client, then this option needs to specify&#10;   the filename for the file that stores the certificate of a certificate authority (CA) that&#10;   this server will use to verify client certificates. This path can be any of those&#10;   understood by the Ptolemy host, e.g. paths beginning with $CLASSPATH/.&#10;   FIXME: Need to be a list of paths for certificates rather than a single path.">
    </property>
    <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
    </property>
</property>