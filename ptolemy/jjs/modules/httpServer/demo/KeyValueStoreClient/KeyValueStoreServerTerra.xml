<?xml version="1.0" standalone="no"?>
<!DOCTYPE entity PUBLIC "-//UC Berkeley//DTD MoML 1//EN"
    "http://ptolemy.eecs.berkeley.edu/xml/dtd/MoML_1.dtd">
<entity name="KeyValueStoreServerTerra" class="ptolemy.actor.TypedCompositeActor">
    <property name="_createdBy" class="ptolemy.kernel.attributes.VersionAttribute" value="11.0.devel">
    </property>
    <property name="DE Director" class="ptolemy.domains.de.kernel.DEDirector">
        <property name="stopWhenQueueIsEmpty" class="ptolemy.data.expr.Parameter" value="false">
        </property>
        <property name="synchronizeToRealTime" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[73.0, 67.0]">
        </property>
    </property>
    <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute" value="{bounds={157, 132, 1235, 744}, maximized=false}">
    </property>
    <property name="_vergilSize" class="ptolemy.actor.gui.SizeAttribute" value="[1001, 634]">
    </property>
    <property name="_vergilZoomFactor" class="ptolemy.data.expr.ExpertParameter" value="1.0">
    </property>
    <property name="_vergilCenter" class="ptolemy.data.expr.ExpertParameter" value="{500.5, 317.0}">
    </property>
    <property name="Annotation" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textSize" class="ptolemy.data.expr.Parameter" value="18">
        </property>
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.0,0.0,0.0,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="This model launches a web server and provides a service&#10;available at http://terra.eecs.berkeley.edu:8099/keyvalue that stores key-value pairs.&#10;Run this model and click on this message to get documentation, or&#10;point your browser to http://terra.eecs.berkeley.edu:8099/keyvalue/help.">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[165.0, 30.0]">
        </property>
        <property name="LiveLink" class="ptolemy.actor.gui.LiveLink" value="http://terra.eecs.berkeley.edu:8099/keyvalue/help#in_browser">
            <property name="_hideName" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
            <property name="_icon" class="ptolemy.vergil.icon.ValueIcon">
                <property name="_color" class="ptolemy.actor.gui.ColorAttribute" value="{0.0, 0.0, 1.0, 1.0}">
                </property>
            </property>
            <property name="_smallIconDescription" class="ptolemy.kernel.util.SingletonConfigurableAttribute">
                <configure>
      <svg>
        <text x="20" style="font-size:14; font-family:SansSerif; fill:blue" y="20">LL</text>
      </svg>
    </configure>
            </property>
            <property name="_editorFactory" class="ptolemy.vergil.toolbox.VisibleParameterEditorFactory">
            </property>
            <property name="_location" class="ptolemy.kernel.util.Location" value="{350, 50}">
            </property>
        </property>
    </property>
    <property name="Annotation2" class="ptolemy.vergil.kernel.attributes.TextAttribute">
        <property name="textColor" class="ptolemy.actor.gui.ColorAttribute" value="{0.6,0.6,0.6,1.0}">
        </property>
        <property name="text" class="ptolemy.kernel.util.StringAttribute" value="Author: Elizabeth Osyk">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[35.0, 600.0]">
        </property>
    </property>
    <entity name="WebServer" class="org.terraswarm.accessor.JSAccessor">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Copyright (c) 2017 The Regents of the University of California.&#10;// All rights reserved.&#10;&#10;// Permission is hereby granted, without written agreement and without&#10;// license or royalty fees, to use, copy, modify, and distribute this&#10;// software and its documentation for any purpose, provided that the above&#10;// copyright notice and the following two paragraphs appear in all copies&#10;// of this software.&#10;&#10;// IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY&#10;// FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES&#10;// ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF&#10;// THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF&#10;// SUCH DAMAGE.&#10;&#10;// THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,&#10;// INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF&#10;// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE&#10;// PROVIDED HEREUNDER IS ON AN &quot;AS IS&quot; BASIS, AND THE UNIVERSITY OF&#10;// CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,&#10;// ENHANCEMENTS, OR MODIFICATIONS.&#10;&#10;/** This accessor starts a server that listens for HTTP requests&#10; *  on the specified hostInterface and port and issues responses.&#10; *  The hostInterface specifies what network interface (e.g. Ethernet,&#10; *  WiFi, or localhost) to use. The default is 'localhost', which (usually)&#10; *  means that the server listens only for requests coming from the local machine.&#10; *  This is useful for testing. To listen for requests on all IPv4 addresses on&#10; *  the local machine, specify '0.0.0.0'. This will make the server accessible&#10; *  to any machine that has access to an IP address for the local machine.&#10; *&#10; *  When this server receives an http requests from the network (or from&#10; *  the local machine), it produces a JavaScript object on the output that&#10; *  includes at least the following properties:&#10; *  &#10; *  * body: The body of the request, or null if there is no body.&#10; *  * method: A string that describes the HTTP method of the request, which&#10; *    may be &quot;GET&quot;, &quot;PUT&quot;, etc.&#10; *  * path: The path in the URL of the request, such as &quot;/&quot; when there is no&#10; *    path.&#10; *  * requestID: An identifier for the request.&#10; *  &#10; *&#10; *  To produce a response, this accessor waits for an input on its *response*&#10; *  port that is a JavaScript object containing the following properties:&#10; *  &#10; *  * requestID: An identifier matching a request for which a response has not&#10; *    already been issued.&#10; *  * response: The body of the response, such as HTML to display to the&#10; *    requester or a JavaScript object with a JSON representation (the JSON&#10; *    representation will be sent back as the response). If this property is&#10; *    not included in the input, then the input will be stringified as a JSON&#10; *    object and sent. This will include the requestID property.&#10; *  &#10; *&#10; *  If there is no pending request with a matching ID, then an error will be&#10; *  issued.&#10; *  &#10; *  A simple use case is to connect the *request* output to some other actor&#10; *  that generates a response, and then to feed that response back to the&#10; *  *response* input. Be sure to include the requestID property in the response.&#10; *&#10; *  When `wrapup()` is invoked, this accessor closes the  server.&#10; *&#10; *  This accessor requires the module httpServer.&#10; *&#10; *  @accessor net/WebServer&#10; *  @parameter {string} hostInterface The IP address or domain name of the&#10; *    network interface to listen to.&#10; *  @parameter {int} port The port to listen on.&#10; *&#10; *  @input response The response to issue to a request. &#10; *  @input shutdown Shutdown the web server.&#10; *  @output {int} listening When the server is listening for connections, this output&#10; *    will produce the port number that the server is listening on&#10; *  @output request The request that came into the server.&#10; *  &#10; *  @author Edward A. Lee amd Elizabeth Osyk&#10; *  @version $$Id$$&#10; */&#10;&#10;// Stop extra messages from jslint and jshint.  Note that there should&#10;// be no space between the / and the * and global. See&#10;// https://chess.eecs.berkeley.edu/ptexternal/wiki/Main/JSHint */&#10;/*globals console, error, exports, require */&#10;/*jshint globalstrict: true*/&#10;'use strict';&#10;&#10;var httpServer = require('@accessors-modules/http-server');&#10;var util = require('util');&#10;&#10;/** Sets up the accessor by defining inputs and outputs. */&#10;exports.setup = function() {&#10;    this.parameter('hostInterface', {&#10;        value: &quot;localhost&quot;,&#10;        type: &quot;string&quot;&#10;    });&#10;    this.parameter('port', {&#10;        value: 80,&#10;        type: &quot;int&quot;&#10;    });&#10;    this.input('response');&#10;    this.output('listening', {'type':'int'});&#10;    this.output('request', {'spontaneous': true});&#10;};&#10;&#10;/** Starts the server.&#10; */&#10;exports.initialize = function() {&#10;    var self = this;&#10;    &#10;    if (!self.server) {&#10;        console.log('WebServer: Creating new server.');&#10;        self.server = new httpServer.HttpServer({&#10;                'port': self.getParameter('port'),&#10;                'hostInterface': self.getParameter('hostInterface')&#10;        });&#10;        // Using 'self.exports' rather than just 'exports' in the following allows&#10;        // these functions to be overridden in derived accessors.&#10;        self.server.on('listening', self.exports.onListening.bind(self));&#10;        self.server.on('request', self.exports.request.bind(self));&#10;        self.server.on('error', function (message) {&#10;            self.error(message);&#10;        });&#10;        self.server.start();&#10;    }&#10;&#10;    self.addInputHandler('response', function() {&#10;        var response = self.get('response');&#10;        if (!response.hasOwnProperty('requestID')) {&#10;            try {&#10;                response = JSON.parse(response);&#10;            } catch (err) {}&#10;            if (!response.hasOwnProperty('requestID')) {&#10;                error('Response has no requestID property: ' + util.inspect(response));&#10;                return;&#10;            }&#10;        }&#10;        var id = response.requestID;&#10;        if (!self.pendingRequests.hasOwnProperty(id)) {&#10;            error('No pending request with ID ' + id);&#10;            return;&#10;        }&#10;        delete self.pendingRequests[id];&#10;        // Default body of the response is the whole response object.&#10;        var body = response;&#10;        if (response.hasOwnProperty('response')) {&#10;            body = response.response;&#10;        }&#10;        if (typeof body !== 'string') {&#10;            body = JSON.stringify(body);&#10;        }&#10;        if (response.hasOwnProperty('responseCode')) {&#10;        	this.server.respond(response.requestID, body, response.responseCode);&#10;        } else {&#10;        	this.server.respond(response.requestID, body);&#10;        }&#10;    });&#10;    &#10;    // Initialize pendingRequests to an empty object.&#10;    self.pendingRequests = {};&#10;};&#10;&#10;exports.onListening = function() {&#10;    console.log('WebServer: Listening for requests.');&#10;    this.send('listening', this.getParameter('port'));&#10;};&#10;&#10;exports.request = function(request) {&#10;	console.log('Server received request.');&#10;    // console.log('Server received request: ' + util.inspect(request));&#10;    if (this.server) {&#10;        this.send('request', request);&#10;        this.pendingRequests[request.requestID] = request;&#10;    } else {&#10;        console.log('WARNING: server does not exist.');&#10;    }&#10;};&#10;&#10;/** Removes all inputHandlers from sockets.&lt;br&gt;&#10; * Unregisters event listeners from sockets.&lt;br&gt;&#10; * Closes server.&#10; */&#10;exports.wrapup = function(){&#10;    if (this.server !== null &amp;&amp; typeof this.server !== 'undefined') {&#10;        console.log('WebServer: Stopping the server.');&#10;        this.server.removeAllListeners();&#10;        this.server.stop();&#10;        this.server = null;&#10;    }&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="accessorSource" class="org.terraswarm.accessor.JSAccessor$ActionableAttribute" value="https://accessors.org/net/WebServer.js">
        </property>
        <property name="documentation" class="ptolemy.vergil.basic.DocAttribute">
            <property name="description" class="ptolemy.kernel.util.StringAttribute" value="&lt;p&gt;This accessor starts a server that listens for HTTP requests&#10; on the specified hostInterface and port and issues responses.&#10; The hostInterface specifies what network interface (e.g. Ethernet,&#10; WiFi, or localhost) to use. The default is 'localhost', which (usually)&#10; means that the server listens only for requests coming from the local machine.&#10; This is useful for testing. To listen for requests on all IPv4 addresses on&#10; the local machine, specify '0.0.0.0'. This will make the server accessible&#10; to any machine that has access to an IP address for the local machine.&lt;/p&gt;&#10;&lt;p&gt; When this server receives an http requests from the network (or from&#10; the local machine), it produces a JavaScript object on the output that&#10; includes at least the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;body: The body of the request, or null if there is no body.&lt;/li&gt;&#10;&lt;li&gt;method: A string that describes the HTTP method of the request, which&#10;may be &amp;quot;GET&amp;quot;, &amp;quot;PUT&amp;quot;, etc.&lt;/li&gt;&#10;&lt;li&gt;path: The path in the URL of the request, such as &amp;quot;/&amp;quot; when there is no&#10;path.&lt;/li&gt;&#10;&lt;li&gt;requestID: An identifier for the request.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; To produce a response, this accessor waits for an input on its &lt;em&gt;response&lt;/em&gt;&#10; port that is a JavaScript object containing the following properties:&lt;/p&gt;&#10;&lt;ul&gt;&#10;&lt;li&gt;requestID: An identifier matching a request for which a response has not&#10;already been issued.&lt;/li&gt;&#10;&lt;li&gt;response: The body of the response, such as HTML to display to the&#10;requester or a JavaScript object with a JSON representation (the JSON&#10;representation will be sent back as the response). If this property is&#10;not included in the input, then the input will be stringified as a JSON&#10;object and sent. This will include the requestID property.&lt;/li&gt;&#10;&lt;/ul&gt;&#10;&lt;p&gt; If there is no pending request with a matching ID, then an error will be&#10; issued.&lt;/p&gt;&#10;&lt;p&gt; A simple use case is to connect the &lt;em&gt;request&lt;/em&gt; output to some other actor&#10; that generates a response, and then to feed that response back to the&#10; &lt;em&gt;response&lt;/em&gt; input. Be sure to include the requestID property in the response.&lt;/p&gt;&#10;&lt;p&gt; When &lt;code&gt;wrapup()&lt;/code&gt; is invoked, this accessor closes the  server.&lt;/p&gt;&#10;&lt;p&gt; This accessor requires the module httpServer.&lt;/p&gt;">
            </property>
            <property name="author" class="ptolemy.kernel.util.StringAttribute" value="Edward A. Lee amd Elizabeth Osyk">
            </property>
            <property name="version" class="ptolemy.kernel.util.StringAttribute" value="$$Id$$">
            </property>
            <property name="response (port)" class="ptolemy.kernel.util.StringAttribute" value="The response to issue to a request.">
            </property>
            <property name="listening (port)" class="ptolemy.kernel.util.StringAttribute" value="When the server is listening for connections, this output&#10;   will produce the port number that the server is listening on">
            </property>
            <property name="request (port)" class="ptolemy.kernel.util.StringAttribute" value="The request that came into the server.">
            </property>
            <property name="hostInterface (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The IP address or domain name of the&#10;   network interface to listen to.">
            </property>
            <property name="port (parameter)" class="ptolemy.kernel.util.StringAttribute" value="The port to listen on.">
            </property>
            <property name="shutdown (port)" class="ptolemy.kernel.util.StringAttribute" value="Shutdown the web server.">
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="hostInterface" class="ptolemy.data.expr.Parameter" value="terra.eecs.berkeley.edu">
            <property name="_stringMode" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[135.0, 285.0]">
        </property>
        <property name="port" class="ptolemy.data.expr.Parameter" value="8099">
        </property>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="listening" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
            <property name="_spontaneous" class="ptolemy.data.expr.SingletonParameter" value="true">
            </property>
        </port>
    </entity>
    <entity name="HelpResponse" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function() {&#10;	this.input('request');&#10;	this.output('response');&#10;}&#10;exports.initialize = function() {&#10;	var self = this;&#10;	this.addInputHandler('request', function() {&#10;		var request = self.get('request');&#10;		var response = {&#10;			requestID: request.requestID,&#10;			response: &quot;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Key-Value Store Service&lt;/h1&gt;&lt;p&gt; &quot; + &#10;&quot;This server and provides a key-value store service. &quot; + &#10;&quot;You can store data indexed by a key and retrieve it from a browser as follows: &quot; + &#10;&quot;&lt;/p&gt;&quot; + &#10;&quot;&lt;ul&gt;&lt;li&gt; To get a help screen (HTML):&lt;pre&gt;&quot; + &#10;&quot;   http://terra.eecs.berkeley.edu:8099/keyvalue/help&quot; + &#10;&quot;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;To store a value with key MY_ID and value MY_VALUE, use&lt;pre&gt;&quot; + &#10;&quot;   http://terra.eecs.berkeley.edu:8099/keyvalue/set?id=MY_ID&amp;value=MY_VALUE&quot; + &#10;&quot;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;To retrieve the value, use&lt;pre&gt;&quot; + &#10;&quot;   http://terra.eecs.berkeley.edu:8099/keyvalue/get?id=MY_ID&quot; + &#10;&quot;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;To remove a value, use&lt;pre&gt;&quot; + &#10;&quot;   http://terra.eecs.berkeley.edu:8099/keyvalue/delete?id=MY_ID&quot; + &#10;&quot;&lt;/pre&gt;&lt;/li&gt;&lt;li&gt;To list all keys (a JSON array of strings), use&lt;pre&gt;&quot; + &#10;&quot;   http://terra.eecs.berkeley.edu:8099/keyvalue/list&quot; + &#10;&quot;&lt;/pre&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&quot; +&#10;&quot;Technically, an application should issue the \&quot;set\&quot; command using an&quot; +&#10;&quot;HTTP POST, not an HTTP GET, but this server will accept either.&quot; +&#10;&quot;&lt;/p&gt;&quot; +&#10;&quot;&lt;p&gt;To experiment with using HTTP POST to set a value, use the \n&quot; +&#10;&quot;&lt;a href=\&quot;https://curl.haxx.se/\&quot;&gt;&lt;code&gt;curl&lt;/code&gt;&lt;/a&gt; program:&lt;/p&gt;\n&quot; +&#10;&quot;&lt;pre&gt;\n&quot; +&#10;&quot;bash-3.2$ &lt;b&gt;curl -X POST -d 'Is still the king.' http://terra.eecs.berkeley.edu:8099/keyvalue/set?id=elvis&lt;/b&gt;\n&quot; +&#10;&quot;&amp;lt;html&amp;gt;elvis set to: undefined&amp;lt;/html&amp;gt;bash-3.2$ &lt;b&gt;wget http://terra.eecs.berkeley.edu:8099/keyvalue/get?id=elvis -O elvis.txt&lt;/b&gt;\n&quot; +&#10;&quot;--2017-10-03 00:09:02--  http://terra.eecs.berkeley.edu:8099/keyvalue/get?id=elvis\n&quot; +&#10;&quot;Resolving terra.eecs.berkeley.edu (terra.eecs.berkeley.edu)... 128.32.48.223\n&quot; +&#10;&quot;Connecting to terra.eecs.berkeley.edu (terra.eecs.berkeley.edu)|128.32.48.223|:8099... connected.\n&quot; +&#10;&quot;HTTP request sent, awaiting response... 200 OK\n&quot; +&#10;&quot;Length: 18 [text/html]\n&quot; +&#10;&quot;Saving to: elvis.txt\n&quot; +&#10;&quot;\n&quot; +&#10;&quot;elvis.txt                              100%[===========================================================================&gt;]      18  --.-KB/s    in 0s\n&quot; +&#10;&quot;\n&quot; +&#10;&quot;2017-10-03 00:09:02 (2.86 MB/s) - elvis.txt saved [18/18]\n&quot; +&#10;&quot;\n&quot; +&#10;&quot;bash-3.2$ &lt;b&gt;cat elvis.txt&lt;/b&gt;\n&quot; +&#10;&quot;Is still the king.bash-3.2$\n&quot; +&#10;&quot;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;&quot;&#10;		};&#10;		self.send('response', response);&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[425.0, 285.0]">
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="PageGenerator" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;&#10;// Needed since the WebServer response port can only have one connection.&#10;&#10;exports.setup = function() {&#10;	this.input('help');&#10;	this.input('list');&#10;	this.input('other');&#10;	this.output('output');&#10;};&#10;&#10;exports.initialize = function() {&#10;	var self = this;&#10;	this.addInputHandler('help', function() {&#10;		self.send('output', self.get('help'));&#10;	});&#10;	&#10;	this.addInputHandler('list', function() {&#10;		self.send('output', self.get('list'));&#10;	});&#10;	&#10;	this.addInputHandler('other', function() {&#10;		self.send('output', self.get('other'));&#10;	});&#10;	&#10;	/*&#10;	this.addInputHandler('list', sendOutput(self.get('list')));&#10;	this.addInputHandler('other', sendOutput(self.get('other')));&#10;		&#10;	var sendOutput = function(data) {&#10;		console.log('sending ' + data);&#10;		self.send('output', data);&#10;	}&#10;	*/&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[755.0, 295.0]">
        </property>
        <port name="help" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="list" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="other" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="output" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="Router" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;&#10;exports.setup = function() {&#10;	this.input('request');&#10;	this.output('help');&#10;	this.output('list');&#10;	this.output('other');&#10;};&#10;&#10;exports.initialize = function() {&#10;	var self = this;&#10;	this.addInputHandler('request', function() {&#10;		var request = self.get('request');&#10;		if (request.path !== null &amp;&amp; typeof request.path !== 'undefined') {&#10;			if (request.path == '/keyvalue/help') {&#10;				self.send('help', request);&#10;			} else if (request.path == '/keyvalue/list') {&#10;				self.send('list', request);&#10;			} else {&#10;				self.send('other', request);&#10;			}&#10;		} else {&#10;			self.send('other', request);&#10;		}&#10;	});&#10;};&#10;&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[260.0, 295.0]">
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
            <property name="_JSON" class="ptolemy.kernel.util.SingletonAttribute">
            </property>
        </port>
        <port name="help" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="list" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="other" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
    </entity>
    <entity name="ListResponse" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function() {&#10;	this.input('request');&#10;	this.input('keys');&#10;	this.output('response');&#10;}&#10;exports.initialize = function() {&#10;	var self = this;&#10;	this.addInputHandler('keys', function() {&#10;		var keys = self.get('keys');&#10;		var requestID = self.get('request').requestID;&#10;		var response = {&#10;			requestID: requestID,&#10;			response: keys&#10;		};&#10;		self.send('response', response);&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[590.0, 360.0]">
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="keys" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="Dictionary" class="ptolemy.actor.lib.Dictionary">
        <property name="file" class="ptolemy.data.expr.FileParameter" value="KeyValueStoreData.txt">
        </property>
        <property name="updateFile" class="ptolemy.data.expr.Parameter" value="true">
        </property>
        <property name="loggingDirectory" class="ptolemy.data.expr.FileParameter" value="$HOME/logs">
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[420.0, 485.0]">
        </property>
    </entity>
    <entity name="TokenToJSON" class="ptolemy.actor.lib.conversions.json.TokenToJSON">
        <property name="_location" class="ptolemy.kernel.util.Location" value="[525.0, 450.0]">
        </property>
    </entity>
    <entity name="ConstructLookup" class="ptolemy.actor.lib.jjs.JavaScript">
        <display name="Construct&#10;Lookup"/>
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="// Put your JavaScript program here.&#10;// Add ports and parameters.&#10;// Define JavaScript functions initialize(), fire(), and/or wrapup().&#10;// Refer to parameters in scope using dollar-sign{parameterName}.&#10;// In the fire() function, use get(parameterName, channel) to read inputs.&#10;// Send to output ports using send(value, portName, channel).&#10;&#10;exports.setup = function() {&#10;	this.input('request');&#10;	this.output('readKey', {'type': 'string'});&#10;	this.output('value', {'type': 'string'});&#10;	this.output('writeKey', {'type': 'string'});&#10;	this.output('response', {'type': 'string'});&#10;	this.output('responseCode', {'type': 'int'});&#10;};&#10;&#10;exports.initialize = function() {&#10;	var self = this;&#10;	this.addInputHandler('request', function() {&#10;		var request = self.get('request');&#10;		&#10;		if (request !== null &amp;&amp; typeof request !== 'undefined' &amp;&amp;&#10;				request.path !== null &amp;&amp; typeof request.path !== 'undefined') {&#10;			var path = request.path;&#10;			var parameters = request.params;&#10;			&#10;			if (path.indexOf('/keyvalue/get') == 0) {&#10;				// Request is get.&#10;				if (parameters.id) {&#10;					self.send('readKey', parameters.id);&#10;				} else {&#10;					self.send('response',&#10;	      				'&lt;html&gt;Error (400): Bad Request. Got parameters: '&#10;	      				+ JSON.stringify(parameters)&#10;	      				+ '&lt;/html&gt;');&#10;      				self.send('responseCode', 400);&#10;				}&#10;			} else if(path.indexOf('/keyvalue/set') == 0) {&#10;				// Request is set.&#10;				if (parameters.id) {&#10;      				self.send('writeKey', parameters.id);&#10;      				// For backward compatibility, a value parameter is allowed.&#10;      				if (typeof parameters.value !== 'undefined') {&#10;      					self.send('value', parameters.value);&#10;      				} else {&#10;      					// Assume a post request, in which case the value&#10;      					// is in the body.&#10;      					self.send('value', request.body);&#10;      				}&#10;      				self.send('response',&#10;      					'&lt;html&gt;'&#10;      					+ parameters.id&#10;      					+ ' set to: '&#10;      					+ parameters.value&#10;      					+ '&lt;/html&gt;');&#10;		    	} else {&#10;		      		self.send('response',&#10;		      			'&lt;html&gt;Error (400): Bad Request. Got parameters: '&#10;		      			+ JSON.stringify(parameters)&#10;		      			+ '&lt;/html&gt;');&#10;		      		self.send('responseCode', 400);&#10;		    	}&#10;			} else if(path.indexOf('/keyvalue/delete') == 0) {&#10;				// Request is delete.&#10;				if (parameters.id) {&#10;      				self.send('writeKey', parameters.id);&#10;      				self.send('response',&#10;      					'&lt;html&gt;' + parameters.id&#10;      					+ ' deleted from store&lt;/html&gt;');&#10;    			} else {&#10;      				self.send('response',&#10;      					'&lt;html&gt;Error (400): Bad Request. Got parameters: '&#10;      					+ JSON.stringify(parameters)&#10;      					+ '&lt;/html&gt;');&#10;      				self.send('responseCode', 400);&#10;    			}&#10;			} else {&#10;				// Request is not recognized.&#10;				self.send('response', '&lt;html&gt;Error (400): Unrecognized Request. Got URI: ' + path + '&lt;/html&gt;');&#10;      			self.send('responseCode', 400);&#10;			}&#10;					&#10;		} else {&#10;			// Request is not recognized.&#10;      		self.send('response', '&lt;html&gt;Error (400): Empty Request. &lt;/html&gt;');&#10;      		self.send('responseCode', 400);&#10;		}&#10;	});&#10;};&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[235.0, 545.0]">
        </property>
        <port name="readKey" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="value" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="writeKey" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="responseCode" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <entity name="KeyValueResponse" class="ptolemy.actor.lib.jjs.JavaScript">
        <property name="_windowProperties" class="ptolemy.actor.gui.WindowPropertiesAttribute">
        </property>
        <property name="_paneSize" class="ptolemy.actor.gui.SizeAttribute">
        </property>
        <property name="script" class="ptolemy.actor.parameters.PortParameter" value="exports.setup = function() {&#10;	this.input('getResult');&#10;	this.input('request');&#10;	this.input('responseBody');&#10;	this.input('responseCode');&#10;	this.input('notFound');&#10;	this.output('response');&#10;}&#10;exports.initialize = function() {&#10;	var self = this;&#10;	&#10;	// Send a response for set and delete requests.&#10;	this.addInputHandler('responseBody', function() {&#10;		console.log('handling body');&#10;		var requestID = self.get('request').requestID;&#10;		var response = {&#10;			requestID: requestID,&#10;			response: self.get('responseBody')&#10;		};&#10;		&#10;		var responseCode = self.get('responseCode');&#10;		if (responseCode !== null) {&#10;			response.responseCode = responseCode;&#10;		}&#10;		&#10;		self.send('response', response);&#10;	});&#10;	&#10;	// Send a response for a successful get request.&#10;	this.addInputHandler('getResult', function() {&#10;		var value = self.get('getResult');&#10;		var requestID = self.get('request').requestID;&#10;		var response = {&#10;			requestID: requestID,&#10;			response: value&#10;		}&#10;		self.send('response', response);&#10;	});&#10;	&#10;	// Send a response for an unsuccessful get request.&#10;	this.addInputHandler('notFound', function() {&#10;		var value =  '&lt;html&gt;Error (404): Not Found.  No value for key.';&#10;		var requestID = self.get('request').requestID;&#10;		var response = {&#10;			requestID: requestID,&#10;			response: value,&#10;			responseCode: 404&#10;		} &#10;		self.send('response', response);&#10;	});&#10;}&#10;">
            <property name="style" class="ptolemy.actor.gui.style.NoteStyle">
                <property name="note" class="ptolemy.kernel.util.StringAttribute" value="NOTE: To see the script, invoke Open Actor">
                </property>
            </property>
        </property>
        <property name="_tableauFactory" class="ptolemy.vergil.toolbox.TextEditorTableauFactory">
            <property name="attributeName" class="ptolemy.kernel.util.StringAttribute" value="script">
            </property>
            <property name="syntaxStyle" class="ptolemy.kernel.util.StringAttribute" value="text/javascript">
            </property>
        </property>
        <property name="_location" class="ptolemy.kernel.util.Location" value="[695.0, 545.0]">
        </property>
        <port name="request" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="response" class="ptolemy.actor.TypedIOPort">
            <property name="output"/>
        </port>
        <port name="responseBody" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="responseCode" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="notFound" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
        <port name="getResult" class="ptolemy.actor.TypedIOPort">
            <property name="input"/>
        </port>
    </entity>
    <relation name="relation" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation8" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[815.0, 170.0]">
        </vertex>
    </relation>
    <relation name="relation5" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation10" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[330.0, 350.0]">
        </vertex>
    </relation>
    <relation name="relation9" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation4" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation12" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[300.0, 420.0]">
        </vertex>
    </relation>
    <relation name="relation6" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation7" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation13" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation14" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation15" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation16" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation19" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[555.0, 475.0]">
        </vertex>
    </relation>
    <relation name="relation17" class="ptolemy.actor.TypedIORelation">
        <vertex name="vertex1" value="[310.0, 465.0]">
        </vertex>
    </relation>
    <relation name="relation2" class="ptolemy.actor.TypedIORelation">
    </relation>
    <relation name="relation3" class="ptolemy.actor.TypedIORelation">
    </relation>
    <link port="WebServer.response" relation="relation8"/>
    <link port="WebServer.request" relation="relation3"/>
    <link port="HelpResponse.request" relation="relation2"/>
    <link port="HelpResponse.response" relation="relation"/>
    <link port="PageGenerator.help" relation="relation"/>
    <link port="PageGenerator.list" relation="relation4"/>
    <link port="PageGenerator.other" relation="relation7"/>
    <link port="PageGenerator.output" relation="relation8"/>
    <link port="Router.request" relation="relation3"/>
    <link port="Router.help" relation="relation2"/>
    <link port="Router.list" relation="relation10"/>
    <link port="Router.other" relation="relation12"/>
    <link port="ListResponse.request" relation="relation10"/>
    <link port="ListResponse.response" relation="relation4"/>
    <link port="ListResponse.keys" relation="relation9"/>
    <link port="Dictionary.keys" relation="relation5"/>
    <link port="Dictionary.readKey" relation="relation17"/>
    <link port="Dictionary.result" relation="relation19"/>
    <link port="Dictionary.triggerKeys" relation="relation10"/>
    <link port="Dictionary.value" relation="relation13"/>
    <link port="Dictionary.writeKey" relation="relation14"/>
    <link port="Dictionary.notFound" relation="relation15"/>
    <link port="TokenToJSON.input" relation="relation5"/>
    <link port="TokenToJSON.output" relation="relation9"/>
    <link port="ConstructLookup.readKey" relation="relation17"/>
    <link port="ConstructLookup.value" relation="relation13"/>
    <link port="ConstructLookup.writeKey" relation="relation14"/>
    <link port="ConstructLookup.response" relation="relation6"/>
    <link port="ConstructLookup.responseCode" relation="relation16"/>
    <link port="ConstructLookup.request" relation="relation12"/>
    <link port="KeyValueResponse.request" relation="relation12"/>
    <link port="KeyValueResponse.response" relation="relation7"/>
    <link port="KeyValueResponse.responseBody" relation="relation6"/>
    <link port="KeyValueResponse.responseCode" relation="relation16"/>
    <link port="KeyValueResponse.notFound" relation="relation15"/>
    <link port="KeyValueResponse.getResult" relation="relation19"/>
</entity>
